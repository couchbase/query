//  Copyright 2015-Present Couchbase, Inc.
//
//  Use of this software is governed by the Business Source License included
//  in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
//  in that file, in accordance with the Business Source License, use of this
//  software will be governed by the Apache License, Version 2.0, included in
//  the file licenses/APL2.txt.

package command

import (
	"io"
	"strings"

	"github.com/couchbase/query/errors"
)

// variable statement_syntax is generated by the build process in syntax_data.go

type Syntax struct {
	ShellCommand
}

func (this *Syntax) Name() string {
	return "SYNTAX"
}

func (this *Syntax) CommandCompletion() bool {
	return false
}

func (this *Syntax) MinArgs() int {
	return ZERO_ARGS
}

func (this *Syntax) MaxArgs() int {
	return MAX_ARGS
}

func (this *Syntax) ExecCommand(args []string) (errors.ErrorCode, string) {
	if !sqlHelp(args...) {
		_, werr := io.WriteString(W, UNKNOWN_STATEMENT)
		if werr != nil {
			return errors.E_SHELL_WRITER_OUTPUT, werr.Error()
		}
	}
	return 0, ""
}

func (this *Syntax) PrintHelp(desc bool) (errors.ErrorCode, string) {
	_, werr := io.WriteString(W, HSYNTAX)
	if desc {
		err_code, err_str := printDesc(this.Name())
		if err_code != 0 {
			return err_code, err_str
		}
	}
	_, werr = io.WriteString(W, "\n")
	if werr != nil {
		return errors.E_SHELL_WRITER_OUTPUT, werr.Error()
	}
	return 0, ""
}

func sqlHelp(terms ...string) bool {
	rules := make(map[string][]int)
	if len(terms) == 0 {
		terms = append(terms, "statements")
	}
	if len(terms) == 1 && remapTerm(terms[0]) == "expr" {
		getRules(rules, "expr", -1, 0, false)
	} else if len(terms) == 1 && remapTerm(terms[0]) == "statement" {
		getRules(rules, "statement", -1, 0, false)
	} else {
		for rule_key, rule := range statement_syntax {
			for opt_num, opt := range rule {
				if len(terms) > len(opt) || len(opt) == 1 {
					continue
				}
				for k := 0; k <= len(opt)-len(terms); k++ {
					matched := 0
					for j := range terms {
						rmt := remapTerm(terms[j])
						if strings.ToUpper(opt[k+j]) == strings.ToUpper(terms[j]) ||
							opt[k+j] == "opt_"+terms[j] ||
							opt[k+j] == rmt ||
							(j == len(terms)-1 && len(rmt) > 2 &&
								(strings.HasPrefix(opt[k+j], rmt) || strings.HasPrefix(strings.ToLower(opt[k+j]), rmt))) {

							matched++
						} else {
							break
						}
					}
					if matched == len(terms) {
						if k == 0 {
							getRules(rules, rule_key, opt_num, 0, true)
						} else {
							getRules(rules, rule_key, opt_num, 0, false)
						}
						break
					}
				}
			}
		}
	}
	if len(rules) == 0 || len(terms) == 1 {
		for _, term := range terms {
			getRules(rules, remapTerm(term), -1, 1, true)
		}
	}
	if len(rules) == 0 {
		if len(terms) == 1 && strings.ToUpper(terms[0]) == terms[0] {
			io.WriteString(W, "<literal text>\n")
			return true
		} else {
			return false
		}
	}
	level := 0
	for len(rules) > 0 {
		for k, v := range rules {
			if v[0] == level {
				printRule(k, v[1:], level != 0)
				delete(rules, k)
			}
		}
		level++
		io.WriteString(W, "\n")
	}
	return true
}

func remapTerm(t string) string {
	switch t {
	case "expression":
		t = "expr"
	case "<expression>":
		t = "expr"
	case "<identifier>":
		t = "identifier"
	case "<identifier>i":
		t = "IDENT_ICASE"
	case "<namespace-identifer>":
		t = "NAMESPACE_ID"
	}
	if len(t) > 2 && t[0] == '[' && t[len(t)-1] == ']' {
		t = "opt_" + t[1:len(t)-1]
	}
	return t
}

func oneLevelOnly(rn string, option int) bool {
	return ((rn == "statement" || rn == "statements") && option == -1) || rn == "expr"
}

func getRules(rules map[string][]int, rn string, option int, level int, nested bool) {
	if strings.Contains(rn, "expr") && level > 0 {
		return
	}
	r, ok := statement_syntax[rn]
	if !ok {
		return
	}
	if r, ok := rules[rn]; ok {
		if option == -1 {
			return
		}
		for i := 1; i < len(r); i++ {
			if r[i] == option {
				return
			}
		}
		if r[0] > level {
			r[0] = level
		}
		rules[rn] = append(r, option)
	} else {
		rules[rn] = []int{level, option}
	}
	if !nested || oneLevelOnly(rn, option) {
		return
	}
	if option != -1 {
		for e := range r[option] {
			getRules(rules, r[option][e], -1, level+1, true)
		}
	} else {
		for o := range r {
			for e := range r[o] {
				getRules(rules, r[o][e], -1, level+1, true)
			}
		}
	}
}

func printRuleOpt(o []string, indent bool, suppressEmpty bool) {
	printed := false
	for i := range o {
		s := o[i]
		if strings.HasPrefix(s, "opt_") {
			s = "[" + s[4:] + "]"
		} else if s == "%empty" {
			if suppressEmpty {
				continue
			}
			s = "<empty rule>"
		} else {
			s = mapRuleName(s)
		}
		if !printed && indent {
			io.WriteString(W, "        ")
		}
		io.WriteString(W, s)
		io.WriteString(W, " ")
		printed = true
	}
	if printed {
		io.WriteString(W, "\n")
	}
}

func mapRuleName(s string) string {
	if s == "IDENT" {
		return "<identifier>"
	} else if s == "IDENT_ICASE" {
		return "<identifier>i"
	} else if s == "NAMESPACE_ID" {
		return "<namespace-identifer>"
	} else if s == "expr" {
		return "<expression>"
	}
	return s
}

func printRule(rn string, options []int, indent bool) {
	r, ok := statement_syntax[rn]
	if !ok {
		return
	}
	if strings.HasPrefix(rn, "opt_") {
		rn = rn[4:]
		if len(r) == 2 && len(r[0]) == 1 && len(r[1]) == 1 && r[0][0] == "%empty" && r[1][0] == rn {
			return
		}
	}
	rn = mapRuleName(rn)
	if indent {
		io.WriteString(W, "    ")
		io.WriteString(W, rn)
		io.WriteString(W, "\n")
	}
	if len(options) == 0 || options[0] == -1 {
		for i := range r {
			printRuleOpt(r[i], indent, len(r) > 1)
		}
	} else {
		for _, o := range options {
			printRuleOpt(r[o], indent, len(r) > 1)
		}
	}
}
