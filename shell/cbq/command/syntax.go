//  Copyright 2015-Present Couchbase, Inc.
//
//  Use of this software is governed by the Business Source License included
//  in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
//  in that file, in accordance with the Business Source License, use of this
//  software will be governed by the Apache License, Version 2.0, included in
//  the file licenses/APL2.txt.

package command

import (
	"strings"

	"github.com/couchbase/query/errors"
)

// variable statement_syntax is generated by the build process in syntax_data.go

type Syntax struct {
	ShellCommand
}

func (this *Syntax) Name() string {
	return "SYNTAX"
}

func (this *Syntax) CommandCompletion() bool {
	return false
}

func (this *Syntax) MinArgs() int {
	return ZERO_ARGS
}

func (this *Syntax) MaxArgs() int {
	return MAX_ARGS
}

func (this *Syntax) ExecCommand(args []string) (errors.ErrorCode, string) {
	OUTPUT.Reset(true)
	defer func() {
		OUTPUT.Write([]byte{0x4})
		OUTPUT.Reset(false)
	}()
	if !sqlHelp(args...) {
		_, werr := OUTPUT.WriteString(UNKNOWN_STATEMENT)
		if werr != nil {
			return errors.E_SHELL_WRITER_OUTPUT, werr.Error()
		}
	}
	return 0, ""
}

func (this *Syntax) PrintHelp(desc bool) (errors.ErrorCode, string) {
	_, werr := OUTPUT.WriteString(HSYNTAX)
	if desc {
		err_code, err_str := printDesc(this.Name())
		if err_code != 0 {
			return err_code, err_str
		}
	}
	_, werr = OUTPUT.WriteString(NEWLINE)
	if werr != nil {
		return errors.E_SHELL_WRITER_OUTPUT, werr.Error()
	}
	return 0, ""
}

func sqlHelp(terms ...string) bool {
	rules := make(map[string][]int)
	if len(terms) == 0 {
		terms = append(terms, "statements")
	}
	if len(terms) == 1 {
		switch terms[0] {
		case "expression":
			getRules(rules, "expression", -1, 0, false)
		case "statement":
			getRules(rules, "statement", -1, 0, false)
		default:
			getRules(rules, terms[0], -1, 0, true)
			if len(rules) == 0 {
				getRules(rules, "["+terms[0]+"]", -1, 0, true)
			}
		}
	}
	if len(rules) == 0 {
		for rule_key, rule := range statement_syntax {
			for opt_num, opt := range rule {
				if len(terms) > len(opt) || len(opt) == 1 {
					continue
				}
				for k := 0; k <= len(opt)-len(terms); k++ {
					matched := 0
					last := len(terms) - 1
					for j := range terms {
						trm := terms[j]
						if opt[k+j] == trm ||
							strings.ToUpper(opt[k+j]) == strings.ToUpper(trm) ||
							opt[k+j] == "["+trm+"]" ||
							(j == last && len(trm) > 2 && (strings.HasPrefix(strings.ToLower(opt[k+j]), trm) ||
								strings.HasPrefix(strings.ToLower(opt[k+j]), "["+trm))) {

							matched++
						} else {
							break
						}
					}
					if matched == len(terms) {
						if k == 0 {
							getRules(rules, rule_key, opt_num, 0, true)
						} else {
							getRules(rules, rule_key, opt_num, 0, false)
						}
						break
					}
				}
			}
		}
	}
	if len(rules) == 0 {
		if len(terms) == 1 && strings.ToUpper(terms[0]) == terms[0] {
			OUTPUT.WriteString("<literal text>" + NEWLINE)
			return true
		} else {
			return false
		}
	}
	level := 0
	for len(rules) > 0 {
		for k, v := range rules {
			if v[0] == level {
				printRule(k, v[1:], level != 0)
				delete(rules, k)
			}
		}
		level++
		OUTPUT.WriteString(NEWLINE)
	}
	return true
}

func oneLevelOnly(rn string, option int) bool {
	return ((rn == "statement" || rn == "statements") && option == -1) || rn == "expr"
}

func getRules(rules map[string][]int, rn string, option int, level int, nested bool) {
	if strings.Contains(rn, "expr") && level > 1 {
		return
	}
	r, ok := statement_syntax[rn]
	if !ok {
		if strings.HasPrefix(rn, "[") && strings.HasSuffix(rn, "]") {
			rn = rn[1 : len(rn)-1]
			r, ok = statement_syntax[rn]
		}
		if !ok {
			return
		}
	}
	if r, ok := rules[rn]; ok {
		if option == -1 {
			return
		}
		for i := 1; i < len(r); i++ {
			if r[i] == option {
				return
			}
		}
		if r[0] > level {
			r[0] = level
		}
		rules[rn] = append(r, option)
	} else {
		rules[rn] = []int{level, option}
	}
	if !nested || oneLevelOnly(rn, option) {
		return
	}
	if option != -1 {
		for e := range r[option] {
			getRules(rules, r[option][e], -1, level+1, true)
		}
	} else {
		for o := range r {
			for e := range r[o] {
				getRules(rules, r[o][e], -1, level+1, true)
			}
		}
	}
}

func printRuleOpt(o []string, indent bool, suppressEmpty bool) {
	printed := false
	for i := range o {
		s := o[i]
		if suppressEmpty && s == "<empty rule>" {
			continue
		}
		if !printed && indent {
			OUTPUT.WriteString("        ")
		}
		OUTPUT.WriteString(s)
		OUTPUT.WriteString(" ")
		printed = true
	}
	if printed {
		OUTPUT.WriteString(NEWLINE)
	}
}

func printRule(rn string, options []int, indent bool) {
	r, ok := statement_syntax[rn]
	if !ok {
		return
	}
	if indent {
		OUTPUT.WriteString("    ")
		OUTPUT.WriteString(rn)
		OUTPUT.WriteString(NEWLINE)
	}
	if len(options) == 0 || options[0] == -1 {
		for i := range r {
			printRuleOpt(r[i], indent, len(r) > 1)
		}
	} else {
		for _, o := range options {
			printRuleOpt(r[o], indent, len(r) > 1)
		}
	}
}
