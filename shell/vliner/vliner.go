//  Copyright 2014-Present Couchbase, Inc.
//
//  Use of this software is governed by the Business Source License included in
//  the file licenses/Couchbase-BSL.txt.  As of the Change Date specified in that
//  file, in accordance with the Business Source License, use of this software will
//  be governed by the Apache License, Version 2.0, included in the file
//  licenses/APL.txt.

package vliner

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/mattn/go-runewidth"
	pliner "github.com/peterh/liner"
)

const (
	ccVINTR = iota
	ccVEOF
	ccVLNEXT
	ccVERASE
	ccVWERASE
	ccVKILL
	ccVSUSP
	ccDigraph
	num_cc
)

const (
	_NORMAL = iota
	_CHANGE_SELECTED
	_CHANGE
	_DELETE_SELECTED
	_DELETE
	_YANK_SELECTED
	_YANK
)

const (
	_REPLAY_END = -1
	_ASCII_NUL  = 0
	_ASCII_TAB  = 9
	_ASCII_ESC  = 27
	_ASCII_VT   = 11
	_ASCII_DEL  = 127
)

type WinSize struct {
	Row    uint16
	Col    uint16
	Xpixel uint16
	Ypixel uint16
}

type State struct {
	r               *bufio.Reader
	pipeIn          bool
	pipeOut         bool
	origMode        Termios
	newMode         Termios
	needsReset      bool
	ws              WinSize
	signals         chan os.Signal
	isig            bool
	buffer          []rune
	history         []string
	replayActive    bool
	recording       bool
	save            []rune
	savePos         int
	cmdRepeat       []rune
	interruptAborts bool
	multiLine       bool
	controlChars    [num_cc]rune
	cx              int
	cy              int
	promptLines     int
	displayStartPos int
}

type digraph struct {
	first  rune
	second rune
	result rune
}

var digraphs = []digraph{
	{'N', 'U', 0 /* ^@ */}, {'S', 'H', 1 /* ^A */}, {'S', 'X', 2 /* ^B */},
	{'E', 'X', 3 /* ^C */}, {'E', 'T', 4 /* ^D */}, {'E', 'Q', 5 /* ^E */},
	{'A', 'K', 6 /* ^F */}, {'B', 'L', 7 /* ^G */}, {'B', 'S', 8 /* ^H */},
	{'H', 'T', 9 /* ^I */}, {'L', 'F', 10 /* ^@ */}, {'V', 'T', 11 /* ^K */},
	{'F', 'F', 12 /* ^L */}, {'C', 'R', 13 /* ^M */}, {'S', 'O', 14 /* ^N */},
	{'S', 'I', 15 /* ^O */}, {'D', 'L', 16 /* ^P */}, {'D', '1', 17 /* ^Q */},
	{'D', '2', 18 /* ^R */}, {'D', '3', 19 /* ^S */}, {'D', '4', 20 /* ^T */},
	{'N', 'K', 21 /* ^U */}, {'S', 'Y', 22 /* ^V */}, {'E', 'B', 23 /* ^W */},
	{'C', 'N', 24 /* ^X */}, {'E', 'M', 25 /* ^Y */}, {'S', 'B', 26 /* ^Z */},
	{'E', 'C', 27 /* ^[ */}, {'F', 'S', 28 /* ^\ */}, {'G', 'S', 29 /* ^] */},
	{'R', 'S', 30 /* ^^ */}, {'U', 'S', 31 /* ^_ */}, {'S', 'P', 32 /*  SP */},
	{'N', 'b', 35 /* # */}, {'D', 'O', 36 /* $ */}, {'A', 't', 64 /* @ */},
	{'<', '(', 91 /* [ */}, {'/', '/', 92 /* \ */}, {')', '>', 93 /* ] */},
	{'\'', '>', 94 /* ^ */}, {'\'', '!', 96 /* ` */}, {'(', '!', 123 /* { */},
	{'!', '!', 124 /* | */}, {'!', ')', 125 /* } */}, {'\'', '?', 126 /* ~ */},
	{'D', 'T', 127 /* ^? */}, {'P', 'A', 128 /* <80> */}, {'H', 'O', 129 /* <81> */},
	{'B', 'H', 130 /* <82> */}, {'N', 'H', 131 /* <83> */}, {'I', 'N', 132 /* <84> */},
	{'N', 'L', 133 /* <85> */}, {'S', 'A', 134 /* <86> */}, {'E', 'S', 135 /* <87> */},
	{'H', 'S', 136 /* <88> */}, {'H', 'J', 137 /* <89> */}, {'V', 'S', 138 /* <8a> */},
	{'P', 'D', 139 /* <8b> */}, {'P', 'U', 140 /* <8c> */}, {'R', 'I', 141 /* <8d> */},
	{'S', '2', 142 /* <8e> */}, {'S', '3', 143 /* <8f> */}, {'D', 'C', 144 /* <90> */},
	{'P', '1', 145 /* <91> */}, {'P', '2', 146 /* <92> */}, {'T', 'S', 147 /* <93> */},
	{'C', 'C', 148 /* <94> */}, {'M', 'W', 149 /* <95> */}, {'S', 'G', 150 /* <96> */},
	{'E', 'G', 151 /* <97> */}, {'S', 'S', 152 /* <98> */}, {'G', 'C', 153 /* <99> */},
	{'S', 'C', 154 /* <9a> */}, {'C', 'I', 155 /* <9b> */}, {'S', 'T', 156 /* <9c> */},
	{'O', 'C', 157 /* <9d> */}, {'P', 'M', 158 /* <9e> */}, {'A', 'C', 159 /* <9f> */},
	{'N', 'S', 160 /*   */}, {'!', 'I', 161 /* ¡ */}, {'~', '!', 161 /* ¡ */},
	{'C', 't', 162 /* ¢ */}, {'c', '|', 162 /* ¢ */}, {'P', 'd', 163 /* £ */},
	{'$', '$', 163 /* £ */}, {'C', 'u', 164 /* ¤ */}, {'o', 'x', 164 /* ¤ */},
	{'Y', 'e', 165 /* ¥ */}, {'Y', '-', 165 /* ¥ */}, {'B', 'B', 166 /* ¦ */},
	{'|', '|', 166 /* ¦ */}, {'S', 'E', 167 /* § */}, {'\'', ':', 168 /* ¨ */},
	{'C', 'o', 169 /* © */}, {'c', 'O', 169 /* © */}, {'-', 'a', 170 /* ª */},
	{'<', '<', 171 /* « */}, {'N', 'O', 172 /* ¬ */}, {'-', ',', 172 /* ¬ */},
	{'-', '-', 173 /* ­ */}, {'R', 'g', 174 /* ® */}, {'\'', 'm', 175 /* ¯ */},
	{'-', '=', 175 /* ¯ */}, {'D', 'G', 176 /* ° */}, {'~', 'o', 176 /* ° */},
	{'+', '-', 177 /* ± */}, {'2', 'S', 178 /* ² */}, {'2', '2', 178 /* ² */},
	{'3', 'S', 179 /* ³ */}, {'3', '3', 179 /* ³ */}, {'\'', '\'', 180 /* ´ */},
	{'M', 'y', 181 /* µ */}, {'P', 'I', 182 /* ¶ */}, {'p', 'p', 182 /* ¶ */},
	{'.', 'M', 183 /* · */}, {'~', '.', 183 /* · */}, {'\'', ',', 184 /* ¸ */},
	{'1', 'S', 185 /* ¹ */}, {'1', '1', 185 /* ¹ */}, {'-', 'o', 186 /* º */},
	{'>', '>', 187 /* » */}, {'1', '4', 188 /* ¼ */}, {'1', '2', 189 /* ½ */},
	{'3', '4', 190 /* ¾ */}, {'?', 'I', 191 /* ¿ */}, {'~', '?', 191 /* ¿ */},
	{'A', '!', 192 /* À */}, {'A', '`', 192 /* À */}, {'A', '\'', 193 /* Á */},
	{'A', '>', 194 /* Â */}, {'A', '^', 194 /* Â */}, {'A', '?', 195 /* Ã */},
	{'A', '~', 195 /* Ã */}, {'A', ':', 196 /* Ä */}, {'A', '"', 196 /* Ä */},
	{'A', 'A', 197 /* Å */}, {'A', '@', 197 /* Å */}, {'A', 'E', 198 /* Æ */},
	{'C', ',', 199 /* Ç */}, {'E', '!', 200 /* È */}, {'E', '`', 200 /* È */},
	{'E', '\'', 201 /* É */}, {'E', '>', 202 /* Ê */}, {'E', '^', 202 /* Ê */},
	{'E', ':', 203 /* Ë */}, {'E', '"', 203 /* Ë */}, {'I', '!', 204 /* Ì */},
	{'I', '`', 204 /* Ì */}, {'I', '\'', 205 /* Í */}, {'I', '>', 206 /* Î */},
	{'I', '^', 206 /* Î */}, {'I', ':', 207 /* Ï */}, {'I', '"', 207 /* Ï */},
	{'D', '-', 208 /* Ð */}, {'N', '?', 209 /* Ñ */}, {'N', '~', 209 /* Ñ */},
	{'O', '!', 210 /* Ò */}, {'O', '`', 210 /* Ò */}, {'O', '\'', 211 /* Ó */},
	{'O', '>', 212 /* Ô */}, {'O', '^', 212 /* Ô */}, {'O', '?', 213 /* Õ */},
	{'O', '~', 213 /* Õ */}, {'O', ':', 214 /* Ö */}, {'*', 'X', 215 /* × */},
	{'/', '\\', 215 /* × */}, {'O', '/', 216 /* Ø */}, {'U', '!', 217 /* Ù */},
	{'U', '`', 217 /* Ù */}, {'U', '\'', 218 /* Ú */}, {'U', '>', 219 /* Û */},
	{'U', '^', 219 /* Û */}, {'U', ':', 220 /* Ü */}, {'Y', '\'', 221 /* Ý */},
	{'T', 'H', 222 /* Þ */}, {'I', 'p', 222 /* Þ */}, {'s', 's', 223 /* ß */},
	{'a', '!', 224 /* à */}, {'a', '`', 224 /* à */}, {'a', '\'', 225 /* á */},
	{'a', '>', 226 /* â */}, {'a', '^', 226 /* â */}, {'a', '?', 227 /* ã */},
	{'a', '~', 227 /* ã */}, {'a', ':', 228 /* ä */}, {'a', '"', 228 /* ä */},
	{'a', 'a', 229 /* å */}, {'a', '@', 229 /* å */}, {'a', 'e', 230 /* æ */},
	{'c', ',', 231 /* ç */}, {'e', '!', 232 /* è */}, {'e', '`', 232 /* è */},
	{'e', '\'', 233 /* é */}, {'e', '>', 234 /* ê */}, {'e', '^', 234 /* ê */},
	{'e', ':', 235 /* ë */}, {'e', '"', 235 /* ë */}, {'i', '!', 236 /* ì */},
	{'i', '`', 236 /* ì */}, {'i', '\'', 237 /* í */}, {'i', '>', 238 /* î */},
	{'i', '^', 238 /* î */}, {'i', ':', 239 /* ï */}, {'d', '-', 240 /* ð */},
	{'n', '?', 241 /* ñ */}, {'n', '~', 241 /* ñ */}, {'o', '!', 242 /* ò */},
	{'o', '`', 242 /* ò */}, {'o', '\'', 243 /* ó */}, {'o', '>', 244 /* ô */},
	{'o', '^', 244 /* ô */}, {'o', '?', 245 /* õ */}, {'o', '~', 245 /* õ */},
	{'o', ':', 246 /* ö */}, {'-', ':', 247 /* ÷ */}, {'o', '/', 248 /* ø */},
	{'u', '!', 249 /* ù */}, {'u', '`', 249 /* ù */}, {'u', '\'', 250 /* ú */},
	{'u', '>', 251 /* û */}, {'u', '^', 251 /* û */}, {'u', ':', 252 /* ü */},
	{'y', '\'', 253 /* ý */}, {'t', 'h', 254 /* þ */}, {'y', ':', 255 /* ÿ */},
	{'y', '"', 255 /* ÿ */}, {'A', '-', 256 /* Ā */}, {'a', '-', 257 /* ā */},
	{'A', '(', 258 /* Ă */}, {'a', '(', 259 /* ă */}, {'A', ';', 260 /* Ą */},
	{'a', ';', 261 /* ą */}, {'C', '\'', 262 /* Ć */}, {'c', '\'', 263 /* ć */},
	{'C', '>', 264 /* Ĉ */}, {'c', '>', 265 /* ĉ */}, {'C', '.', 266 /* Ċ */},
	{'c', '.', 267 /* ċ */}, {'C', '<', 268 /* Č */}, {'c', '<', 269 /* č */},
	{'D', '<', 270 /* Ď */}, {'d', '<', 271 /* ď */}, {'D', '/', 272 /* Đ */},
	{'d', '/', 273 /* đ */}, {'E', '-', 274 /* Ē */}, {'e', '-', 275 /* ē */},
	{'E', '(', 276 /* Ĕ */}, {'e', '(', 277 /* ĕ */}, {'E', '.', 278 /* Ė */},
	{'e', '.', 279 /* ė */}, {'E', ';', 280 /* Ę */}, {'e', ';', 281 /* ę */},
	{'E', '<', 282 /* Ě */}, {'e', '<', 283 /* ě */}, {'G', '>', 284 /* Ĝ */},
	{'g', '>', 285 /* ĝ */}, {'G', '(', 286 /* Ğ */}, {'g', '(', 287 /* ğ */},
	{'G', '.', 288 /* Ġ */}, {'g', '.', 289 /* ġ */}, {'G', ',', 290 /* Ģ */},
	{'g', ',', 291 /* ģ */}, {'H', '>', 292 /* Ĥ */}, {'h', '>', 293 /* ĥ */},
	{'H', '/', 294 /* Ħ */}, {'h', '/', 295 /* ħ */}, {'I', '?', 296 /* Ĩ */},
	{'i', '?', 297 /* ĩ */}, {'I', '-', 298 /* Ī */}, {'i', '-', 299 /* ī */},
	{'I', '(', 300 /* Ĭ */}, {'i', '(', 301 /* ĭ */}, {'I', ';', 302 /* Į */},
	{'i', ';', 303 /* į */}, {'I', '.', 304 /* İ */}, {'i', '.', 305 /* ı */},
	{'I', 'J', 306 /* Ĳ */}, {'i', 'j', 307 /* ĳ */}, {'J', '>', 308 /* Ĵ */},
	{'j', '>', 309 /* ĵ */}, {'K', ',', 310 /* Ķ */}, {'k', ',', 311 /* ķ */},
	{'k', 'k', 312 /* ĸ */}, {'L', '\'', 313 /* Ĺ */}, {'l', '\'', 314 /* ĺ */},
	{'L', ',', 315 /* Ļ */}, {'l', ',', 316 /* ļ */}, {'L', '<', 317 /* Ľ */},
	{'l', '<', 318 /* ľ */}, {'L', '.', 319 /* Ŀ */}, {'l', '.', 320 /* ŀ */},
	{'L', '/', 321 /* Ł */}, {'l', '/', 322 /* ł */}, {'N', '\'', 323 /* Ń */},
	{'n', '\'', 324 /* ń */}, {'N', ',', 325 /* Ņ */}, {'n', ',', 326 /* ņ */},
	{'N', '<', 327 /* Ň */}, {'n', '<', 328 /* ň */}, {'\'', 'n', 329 /* ŉ */},
	{'N', 'G', 330 /* Ŋ */}, {'n', 'g', 331 /* ŋ */}, {'O', '-', 332 /* Ō */},
	{'o', '-', 333 /* ō */}, {'O', '(', 334 /* Ŏ */}, {'o', '(', 335 /* ŏ */},
	{'O', '"', 336 /* Ő */}, {'o', '"', 337 /* ő */}, {'O', 'E', 338 /* Œ */},
	{'o', 'e', 339 /* œ */}, {'R', '\'', 340 /* Ŕ */}, {'r', '\'', 341 /* ŕ */},
	{'R', ',', 342 /* Ŗ */}, {'r', ',', 343 /* ŗ */}, {'R', '<', 344 /* Ř */},
	{'r', '<', 345 /* ř */}, {'S', '\'', 346 /* Ś */}, {'s', '\'', 347 /* ś */},
	{'S', '>', 348 /* Ŝ */}, {'s', '>', 349 /* ŝ */}, {'S', ',', 350 /* Ş */},
	{'s', ',', 351 /* ş */}, {'S', '<', 352 /* Š */}, {'s', '<', 353 /* š */},
	{'T', ',', 354 /* Ţ */}, {'t', ',', 355 /* ţ */}, {'T', '<', 356 /* Ť */},
	{'t', '<', 357 /* ť */}, {'T', '/', 358 /* Ŧ */}, {'t', '/', 359 /* ŧ */},
	{'U', '?', 360 /* Ũ */}, {'u', '?', 361 /* ũ */}, {'U', '-', 362 /* Ū */},
	{'u', '-', 363 /* ū */}, {'U', '(', 364 /* Ŭ */}, {'u', '(', 365 /* ŭ */},
	{'U', '0', 366 /* Ů */}, {'u', '0', 367 /* ů */}, {'U', '"', 368 /* Ű */},
	{'u', '"', 369 /* ű */}, {'U', ';', 370 /* Ų */}, {'u', ';', 371 /* ų */},
	{'W', '>', 372 /* Ŵ */}, {'w', '>', 373 /* ŵ */}, {'Y', '>', 374 /* Ŷ */},
	{'y', '>', 375 /* ŷ */}, {'Y', ':', 376 /* Ÿ */}, {'Z', '\'', 377 /* Ź */},
	{'z', '\'', 378 /* ź */}, {'Z', '.', 379 /* Ż */}, {'z', '.', 380 /* ż */},
	{'Z', '<', 381 /* Ž */}, {'z', '<', 382 /* ž */}, {'O', '9', 416 /* Ơ */},
	{'o', '9', 417 /* ơ */}, {'O', 'I', 418 /* Ƣ */}, {'o', 'i', 419 /* ƣ */},
	{'y', 'r', 422 /* Ʀ */}, {'U', '9', 431 /* Ư */}, {'u', '9', 432 /* ư */},
	{'Z', '/', 437 /* Ƶ */}, {'z', '/', 438 /* ƶ */}, {'E', 'D', 439 /* Ʒ */},
	{'A', '<', 461 /* Ǎ */}, {'a', '<', 462 /* ǎ */}, {'I', '<', 463 /* Ǐ */},
	{'i', '<', 464 /* ǐ */}, {'O', '<', 465 /* Ǒ */}, {'o', '<', 466 /* ǒ */},
	{'U', '<', 467 /* Ǔ */}, {'u', '<', 468 /* ǔ */}, {'A', '1', 478 /* Ǟ */},
	{'a', '1', 479 /* ǟ */}, {'A', '7', 480 /* Ǡ */}, {'a', '7', 481 /* ǡ */},
	{'A', '3', 482 /* Ǣ */}, {'a', '3', 483 /* ǣ */}, {'G', '/', 484 /* Ǥ */},
	{'g', '/', 485 /* ǥ */}, {'G', '<', 486 /* Ǧ */}, {'g', '<', 487 /* ǧ */},
	{'K', '<', 488 /* Ǩ */}, {'k', '<', 489 /* ǩ */}, {'O', ';', 490 /* Ǫ */},
	{'o', ';', 491 /* ǫ */}, {'O', '1', 492 /* Ǭ */}, {'o', '1', 493 /* ǭ */},
	{'E', 'Z', 494 /* Ǯ */}, {'e', 'z', 495 /* ǯ */}, {'j', '<', 496 /* ǰ */},
	{'G', '\'', 500 /* Ǵ */}, {'g', '\'', 501 /* ǵ */}, {';', 'S', 703 /* ʿ */},
	{'\'', '<', 711 /* ˇ */}, {'\'', '(', 728 /* ˘ */}, {'\'', '.', 729 /* ˙ */},
	{'\'', '0', 730 /* ˚ */}, {'\'', ';', 731 /* ˛ */}, {'\'', '"', 733 /* ˝ */},
	{'A', '%', 902 /* Ά */}, {'E', '%', 904 /* Έ */}, {'Y', '%', 905 /* Ή */},
	{'I', '%', 906 /* Ί */}, {'O', '%', 908 /* Ό */}, {'U', '%', 910 /* Ύ */},
	{'W', '%', 911 /* Ώ */}, {'i', '3', 912 /* ΐ */}, {'A', '*', 913 /* Α */},
	{'B', '*', 914 /* Β */}, {'G', '*', 915 /* Γ */}, {'D', '*', 916 /* Δ */},
	{'E', '*', 917 /* Ε */}, {'Z', '*', 918 /* Ζ */}, {'Y', '*', 919 /* Η */},
	{'H', '*', 920 /* Θ */}, {'I', '*', 921 /* Ι */}, {'K', '*', 922 /* Κ */},
	{'L', '*', 923 /* Λ */}, {'M', '*', 924 /* Μ */}, {'N', '*', 925 /* Ν */},
	{'C', '*', 926 /* Ξ */}, {'O', '*', 927 /* Ο */}, {'P', '*', 928 /* Π */},
	{'R', '*', 929 /* Ρ */}, {'S', '*', 931 /* Σ */}, {'T', '*', 932 /* Τ */},
	{'U', '*', 933 /* Υ */}, {'F', '*', 934 /* Φ */}, {'X', '*', 935 /* Χ */},
	{'Q', '*', 936 /* Ψ */}, {'W', '*', 937 /* Ω */}, {'J', '*', 938 /* Ϊ */},
	{'V', '*', 939 /* Ϋ */}, {'a', '%', 940 /* ά */}, {'e', '%', 941 /* έ */},
	{'y', '%', 942 /* ή */}, {'i', '%', 943 /* ί */}, {'u', '3', 944 /* ΰ */},
	{'a', '*', 945 /* α */}, {'b', '*', 946 /* β */}, {'g', '*', 947 /* γ */},
	{'d', '*', 948 /* δ */}, {'e', '*', 949 /* ε */}, {'z', '*', 950 /* ζ */},
	{'y', '*', 951 /* η */}, {'h', '*', 952 /* θ */}, {'i', '*', 953 /* ι */},
	{'k', '*', 954 /* κ */}, {'l', '*', 955 /* λ */}, {'m', '*', 956 /* μ */},
	{'n', '*', 957 /* ν */}, {'c', '*', 958 /* ξ */}, {'o', '*', 959 /* ο */},
	{'p', '*', 960 /* π */}, {'r', '*', 961 /* ρ */}, {'*', 's', 962 /* ς */},
	{'s', '*', 963 /* σ */}, {'t', '*', 964 /* τ */}, {'u', '*', 965 /* υ */},
	{'f', '*', 966 /* φ */}, {'x', '*', 967 /* χ */}, {'q', '*', 968 /* ψ */},
	{'w', '*', 969 /* ω */}, {'j', '*', 970 /* ϊ */}, {'v', '*', 971 /* ϋ */},
	{'o', '%', 972 /* ό */}, {'u', '%', 973 /* ύ */}, {'w', '%', 974 /* ώ */},
	{'\'', 'G', 984 /* Ϙ */}, {',', 'G', 985 /* ϙ */}, {'T', '3', 986 /* Ϛ */},
	{'t', '3', 987 /* ϛ */}, {'M', '3', 988 /* Ϝ */}, {'m', '3', 989 /* ϝ */},
	{'K', '3', 990 /* Ϟ */}, {'k', '3', 991 /* ϟ */}, {'P', '3', 992 /* Ϡ */},
	{'p', '3', 993 /* ϡ */}, {'\'', '%', 1012 /* ϴ */}, {'j', '3', 1013 /* ϵ */},
	{'I', 'O', 1025 /* Ё */}, {'D', '%', 1026 /* Ђ */}, {'G', '%', 1027 /* Ѓ */},
	{'I', 'E', 1028 /* Є */}, {'D', 'S', 1029 /* Ѕ */}, {'I', 'I', 1030 /* І */},
	{'Y', 'I', 1031 /* Ї */}, {'J', '%', 1032 /* Ј */}, {'L', 'J', 1033 /* Љ */},
	{'N', 'J', 1034 /* Њ */}, {'T', 's', 1035 /* Ћ */}, {'K', 'J', 1036 /* Ќ */},
	{'V', '%', 1038 /* Ў */}, {'D', 'Z', 1039 /* Џ */}, {'A', '=', 1040 /* А */},
	{'B', '=', 1041 /* Б */}, {'V', '=', 1042 /* В */}, {'G', '=', 1043 /* Г */},
	{'D', '=', 1044 /* Д */}, {'E', '=', 1045 /* Е */}, {'Z', '%', 1046 /* Ж */},
	{'Z', '=', 1047 /* З */}, {'I', '=', 1048 /* И */}, {'J', '=', 1049 /* Й */},
	{'K', '=', 1050 /* К */}, {'L', '=', 1051 /* Л */}, {'M', '=', 1052 /* М */},
	{'N', '=', 1053 /* Н */}, {'O', '=', 1054 /* О */}, {'P', '=', 1055 /* П */},
	{'R', '=', 1056 /* Р */}, {'S', '=', 1057 /* С */}, {'T', '=', 1058 /* Т */},
	{'U', '=', 1059 /* У */}, {'F', '=', 1060 /* Ф */}, {'H', '=', 1061 /* Х */},
	{'C', '=', 1062 /* Ц */}, {'C', '%', 1063 /* Ч */}, {'S', '%', 1064 /* Ш */},
	{'S', 'c', 1065 /* Щ */}, {'=', '"', 1066 /* Ъ */}, {'Y', '=', 1067 /* Ы */},
	{'%', '"', 1068 /* Ь */}, {'J', 'E', 1069 /* Э */}, {'J', 'U', 1070 /* Ю */},
	{'J', 'A', 1071 /* Я */}, {'a', '=', 1072 /* а */}, {'b', '=', 1073 /* б */},
	{'v', '=', 1074 /* в */}, {'g', '=', 1075 /* г */}, {'d', '=', 1076 /* д */},
	{'e', '=', 1077 /* е */}, {'z', '%', 1078 /* ж */}, {'z', '=', 1079 /* з */},
	{'i', '=', 1080 /* и */}, {'j', '=', 1081 /* й */}, {'k', '=', 1082 /* к */},
	{'l', '=', 1083 /* л */}, {'m', '=', 1084 /* м */}, {'n', '=', 1085 /* н */},
	{'o', '=', 1086 /* о */}, {'p', '=', 1087 /* п */}, {'r', '=', 1088 /* р */},
	{'s', '=', 1089 /* с */}, {'t', '=', 1090 /* т */}, {'u', '=', 1091 /* у */},
	{'f', '=', 1092 /* ф */}, {'h', '=', 1093 /* х */}, {'c', '=', 1094 /* ц */},
	{'c', '%', 1095 /* ч */}, {'s', '%', 1096 /* ш */}, {'s', 'c', 1097 /* щ */},
	{'=', '\'', 1098 /* ъ */}, {'y', '=', 1099 /* ы */}, {'%', '\'', 1100 /* ь */},
	{'j', 'e', 1101 /* э */}, {'j', 'u', 1102 /* ю */}, {'j', 'a', 1103 /* я */},
	{'i', 'o', 1105 /* ё */}, {'d', '%', 1106 /* ђ */}, {'g', '%', 1107 /* ѓ */},
	{'i', 'e', 1108 /* є */}, {'d', 's', 1109 /* ѕ */}, {'i', 'i', 1110 /* і */},
	{'y', 'i', 1111 /* ї */}, {'j', '%', 1112 /* ј */}, {'l', 'j', 1113 /* љ */},
	{'n', 'j', 1114 /* њ */}, {'t', 's', 1115 /* ћ */}, {'k', 'j', 1116 /* ќ */},
	{'v', '%', 1118 /* ў */}, {'d', 'z', 1119 /* џ */}, {'Y', '3', 1122 /* Ѣ */},
	{'y', '3', 1123 /* ѣ */}, {'O', '3', 1130 /* Ѫ */}, {'o', '3', 1131 /* ѫ */},
	{'F', '3', 1138 /* Ѳ */}, {'f', '3', 1139 /* ѳ */}, {'V', '3', 1140 /* Ѵ */},
	{'v', '3', 1141 /* ѵ */}, {'C', '3', 1152 /* Ҁ */}, {'c', '3', 1153 /* ҁ */},
	{'G', '3', 1168 /* Ґ */}, {'g', '3', 1169 /* ґ */}, {'A', '+', 1488 /* א */},
	{'B', '+', 1489 /* ב */}, {'G', '+', 1490 /* ג */}, {'D', '+', 1491 /* ד */},
	{'H', '+', 1492 /* ה */}, {'W', '+', 1493 /* ו */}, {'Z', '+', 1494 /* ז */},
	{'X', '+', 1495 /* ח */}, {'T', 'j', 1496 /* ט */}, {'J', '+', 1497 /* י */},
	{'K', '%', 1498 /* ך */}, {'K', '+', 1499 /* כ */}, {'L', '+', 1500 /* ל */},
	{'M', '%', 1501 /* ם */}, {'M', '+', 1502 /* מ */}, {'N', '%', 1503 /* ן */},
	{'N', '+', 1504 /* נ */}, {'S', '+', 1505 /* ס */}, {'E', '+', 1506 /* ע */},
	{'P', '%', 1507 /* ף */}, {'P', '+', 1508 /* פ */}, {'Z', 'j', 1509 /* ץ */},
	{'Z', 'J', 1510 /* צ */}, {'Q', '+', 1511 /* ק */}, {'R', '+', 1512 /* ר */},
	{'S', 'h', 1513 /* ש */}, {'T', '+', 1514 /* ת */}, {',', '+', 1548 /* ، */},
	{';', '+', 1563 /* ؛ */}, {'?', '+', 1567 /* ؟ */}, {'H', '\'', 1569 /* ﺀ */},
	{'a', 'M', 1570 /* ﺁ */}, {'a', 'H', 1571 /* ﺃ */}, {'w', 'H', 1572 /* ﺅ */},
	{'a', 'h', 1573 /* ﺇ */}, {'y', 'H', 1574 /* ﺉ */}, {'a', '+', 1575 /* ﺍ */},
	{'b', '+', 1576 /* ﺏ */}, {'t', 'm', 1577 /* ﺓ */}, {'t', '+', 1578 /* ﺕ */},
	{'t', 'k', 1579 /* ﺙ */}, {'g', '+', 1580 /* ﺝ */}, {'h', 'k', 1581 /* ﺡ */},
	{'x', '+', 1582 /* ﺥ */}, {'d', '+', 1583 /* ﺩ */}, {'d', 'k', 1584 /* ﺫ */},
	{'r', '+', 1585 /* ﺭ */}, {'z', '+', 1586 /* ﺯ */}, {'s', '+', 1587 /* ﺱ */},
	{'s', 'n', 1588 /* ﺵ */}, {'c', '+', 1589 /* ﺹ */}, {'d', 'd', 1590 /* ﺽ */},
	{'t', 'j', 1591 /* ﻁ */}, {'z', 'H', 1592 /* ﻅ */}, {'e', '+', 1593 /* ﻉ */},
	{'i', '+', 1594 /* ﻍ */}, {'+', '+', 1600 /* ـ */}, {'f', '+', 1601 /* ﻑ */},
	{'q', '+', 1602 /* ﻕ */}, {'k', '+', 1603 /* ﻙ */}, {'l', '+', 1604 /* ﻝ */},
	{'m', '+', 1605 /* ﻡ */}, {'n', '+', 1606 /* ﻥ */}, {'h', '+', 1607 /* ﻩ */},
	{'w', '+', 1608 /* ﻭ */}, {'j', '+', 1609 /* ﻯ */}, {'y', '+', 1610 /* ﻱ */},
	{':', '+', 1611 /*  ً */}, {'"', '+', 1612 /*  ٌ */}, {'=', '+', 1613 /*  ٍ */},
	{'/', '+', 1614 /*  َ */}, {'\'', '+', 1615 /*  ُ */}, {'1', '+', 1616 /*  ِ */},
	{'3', '+', 1617 /*  ّ */}, {'0', '+', 1618 /*  ْ */}, {'a', 'S', 1648 /*  ٰ */},
	{'p', '+', 1662 /* ﭖ */}, {'v', '+', 1700 /* ڤ */}, {'g', 'f', 1711 /* ﮒ */},
	{'0', 'a', 1776 /* ۰ */}, {'1', 'a', 1777 /* ۱ */}, {'2', 'a', 1778 /* ۲ */},
	{'3', 'a', 1779 /* ۳ */}, {'4', 'a', 1780 /* ۴ */}, {'5', 'a', 1781 /* ۵ */},
	{'6', 'a', 1782 /* ۶ */}, {'7', 'a', 1783 /* ۷ */}, {'8', 'a', 1784 /* ۸ */},
	{'9', 'a', 1785 /* ۹ */}, {'B', '.', 7682 /* Ḃ */}, {'b', '.', 7683 /* ḃ */},
	{'B', '_', 7686 /* Ḇ */}, {'b', '_', 7687 /* ḇ */}, {'D', '.', 7690 /* Ḋ */},
	{'d', '.', 7691 /* ḋ */}, {'D', '_', 7694 /* Ḏ */}, {'d', '_', 7695 /* ḏ */},
	{'D', ',', 7696 /* Ḑ */}, {'d', ',', 7697 /* ḑ */}, {'F', '.', 7710 /* Ḟ */},
	{'f', '.', 7711 /* ḟ */}, {'G', '-', 7712 /* Ḡ */}, {'g', '-', 7713 /* ḡ */},
	{'H', '.', 7714 /* Ḣ */}, {'h', '.', 7715 /* ḣ */}, {'H', ':', 7718 /* Ḧ */},
	{'h', ':', 7719 /* ḧ */}, {'H', ',', 7720 /* Ḩ */}, {'h', ',', 7721 /* ḩ */},
	{'K', '\'', 7728 /* Ḱ */}, {'k', '\'', 7729 /* ḱ */}, {'K', '_', 7732 /* Ḵ */},
	{'k', '_', 7733 /* ḵ */}, {'L', '_', 7738 /* Ḻ */}, {'l', '_', 7739 /* ḻ */},
	{'M', '\'', 7742 /* Ḿ */}, {'m', '\'', 7743 /* ḿ */}, {'M', '.', 7744 /* Ṁ */},
	{'m', '.', 7745 /* ṁ */}, {'N', '.', 7748 /* Ṅ */}, {'n', '.', 7749 /* ṅ */},
	{'N', '_', 7752 /* Ṉ */}, {'n', '_', 7753 /* ṉ */}, {'P', '\'', 7764 /* Ṕ */},
	{'p', '\'', 7765 /* ṕ */}, {'P', '.', 7766 /* Ṗ */}, {'p', '.', 7767 /* ṗ */},
	{'R', '.', 7768 /* Ṙ */}, {'r', '.', 7769 /* ṙ */}, {'R', '_', 7774 /* Ṟ */},
	{'r', '_', 7775 /* ṟ */}, {'S', '.', 7776 /* Ṡ */}, {'s', '.', 7777 /* ṡ */},
	{'T', '.', 7786 /* Ṫ */}, {'t', '.', 7787 /* ṫ */}, {'T', '_', 7790 /* Ṯ */},
	{'t', '_', 7791 /* ṯ */}, {'V', '?', 7804 /* Ṽ */}, {'v', '?', 7805 /* ṽ */},
	{'W', '!', 7808 /* Ẁ */}, {'W', '`', 7808 /* Ẁ */}, {'w', '!', 7809 /* ẁ */},
	{'w', '`', 7809 /* ẁ */}, {'W', '\'', 7810 /* Ẃ */}, {'w', '\'', 7811 /* ẃ */},
	{'W', ':', 7812 /* Ẅ */}, {'w', ':', 7813 /* ẅ */}, {'W', '.', 7814 /* Ẇ */},
	{'w', '.', 7815 /* ẇ */}, {'X', '.', 7818 /* Ẋ */}, {'x', '.', 7819 /* ẋ */},
	{'X', ':', 7820 /* Ẍ */}, {'x', ':', 7821 /* ẍ */}, {'Y', '.', 7822 /* Ẏ */},
	{'y', '.', 7823 /* ẏ */}, {'Z', '>', 7824 /* Ẑ */}, {'z', '>', 7825 /* ẑ */},
	{'Z', '_', 7828 /* Ẕ */}, {'z', '_', 7829 /* ẕ */}, {'h', '_', 7830 /* ẖ */},
	{'t', ':', 7831 /* ẗ */}, {'w', '0', 7832 /* ẘ */}, {'y', '0', 7833 /* ẙ */},
	{'A', '2', 7842 /* Ả */}, {'a', '2', 7843 /* ả */}, {'E', '2', 7866 /* Ẻ */},
	{'e', '2', 7867 /* ẻ */}, {'E', '?', 7868 /* Ẽ */}, {'e', '?', 7869 /* ẽ */},
	{'I', '2', 7880 /* Ỉ */}, {'i', '2', 7881 /* ỉ */}, {'O', '2', 7886 /* Ỏ */},
	{'o', '2', 7887 /* ỏ */}, {'U', '2', 7910 /* Ủ */}, {'u', '2', 7911 /* ủ */},
	{'Y', '!', 7922 /* Ỳ */}, {'Y', '`', 7922 /* Ỳ */}, {'y', '!', 7923 /* ỳ */},
	{'y', '`', 7923 /* ỳ */}, {'Y', '2', 7926 /* Ỷ */}, {'y', '2', 7927 /* ỷ */},
	{'Y', '?', 7928 /* Ỹ */}, {'y', '?', 7929 /* ỹ */}, {';', '\'', 7936 /* ἀ */},
	{',', '\'', 7937 /* ἁ */}, {';', '!', 7938 /* ἂ */}, {',', '!', 7939 /* ἃ */},
	{'?', ';', 7940 /* ἄ */}, {'?', ',', 7941 /* ἅ */}, {'!', ':', 7942 /* ἆ */},
	{'?', ':', 7943 /* ἇ */}, {'1', 'N', 8194 /*   */}, {'1', 'M', 8195 /*   */},
	{'3', 'M', 8196 /*   */}, {'4', 'M', 8197 /*   */}, {'6', 'M', 8198 /*   */},
	{'1', 'T', 8201 /*   */}, {'1', 'H', 8202 /*   */}, {'-', '1', 8208 /* ‐ */},
	{'-', 'N', 8211 /* – */}, {'-', 'M', 8212 /* — */}, {'-', '3', 8213 /* ― */},
	{'!', '2', 8214 /* ‖ */}, {'=', '2', 8215 /* ‗ */}, {'\'', '6', 8216 /* ‘ */},
	{'\'', '9', 8217 /* ’ */}, {'.', '9', 8218 /* ‚ */}, {'9', '\'', 8219 /* ‛ */},
	{'"', '6', 8220 /* “ */}, {'"', '9', 8221 /* ” */}, {':', '9', 8222 /* „ */},
	{'9', '"', 8223 /* ‟ */}, {'/', '-', 8224 /* † */}, {'/', '=', 8225 /* ‡ */},
	{'.', '.', 8229 /* ‥ */}, {',', '.', 8230 /* … */}, {'%', '0', 8240 /* ‰ */},
	{'1', '\'', 8242 /* ′ */}, {'2', '\'', 8243 /* ″ */}, {'3', '\'', 8244 /* ‴ */},
	{'1', '"', 8245 /* ‵ */}, {'2', '"', 8246 /* ‶ */}, {'3', '"', 8247 /* ‷ */},
	{'C', 'a', 8248 /* ‸ */}, {'<', '1', 8249 /* ‹ */}, {'>', '1', 8250 /* › */},
	{':', 'X', 8251 /* ※ */}, {'\'', '-', 8254 /* ‾ */}, {'/', 'f', 8260 /* ⁄ */},
	{'0', 'S', 8304 /* ⁰ */}, {'4', 'S', 8308 /* ⁴ */}, {'5', 'S', 8309 /* ⁵ */},
	{'6', 'S', 8310 /* ⁶ */}, {'7', 'S', 8311 /* ⁷ */}, {'8', 'S', 8312 /* ⁸ */},
	{'9', 'S', 8313 /* ⁹ */}, {'+', 'S', 8314 /* ⁺ */}, {'-', 'S', 8315 /* ⁻ */},
	{'=', 'S', 8316 /* ⁼ */}, {'(', 'S', 8317 /* ⁽ */}, {')', 'S', 8318 /* ⁾ */},
	{'n', 'S', 8319 /* ⁿ */}, {'0', 's', 8320 /* ₀ */}, {'1', 's', 8321 /* ₁ */},
	{'2', 's', 8322 /* ₂ */}, {'3', 's', 8323 /* ₃ */}, {'4', 's', 8324 /* ₄ */},
	{'5', 's', 8325 /* ₅ */}, {'6', 's', 8326 /* ₆ */}, {'7', 's', 8327 /* ₇ */},
	{'8', 's', 8328 /* ₈ */}, {'9', 's', 8329 /* ₉ */}, {'+', 's', 8330 /* ₊ */},
	{'-', 's', 8331 /* ₋ */}, {'=', 's', 8332 /* ₌ */}, {'(', 's', 8333 /* ₍ */},
	{')', 's', 8334 /* ₎ */}, {'L', 'i', 8356 /* ₤ */}, {'P', 't', 8359 /* ₧ */},
	{'W', '=', 8361 /* ₩ */}, {'=', 'e', 8364 /* € */}, {'E', 'u', 8364 /* € */},
	{'=', 'R', 8381 /* ₽ */}, {'=', 'P', 8381 /* ₽ */}, {'o', 'C', 8451 /* ℃ */},
	{'c', 'o', 8453 /* ℅ */}, {'o', 'F', 8457 /* ℉ */}, {'N', '0', 8470 /* № */},
	{'P', 'O', 8471 /* ℗ */}, {'R', 'x', 8478 /* ℞ */}, {'S', 'M', 8480 /* ℠ */},
	{'T', 'M', 8482 /* ™ */}, {'O', 'm', 8486 /* Ω */}, {'A', 'O', 8491 /* Å */},
	{'1', '3', 8531 /* ⅓ */}, {'2', '3', 8532 /* ⅔ */}, {'1', '5', 8533 /* ⅕ */},
	{'2', '5', 8534 /* ⅖ */}, {'3', '5', 8535 /* ⅗ */}, {'4', '5', 8536 /* ⅘ */},
	{'1', '6', 8537 /* ⅙ */}, {'5', '6', 8538 /* ⅚ */}, {'1', '8', 8539 /* ⅛ */},
	{'3', '8', 8540 /* ⅜ */}, {'5', '8', 8541 /* ⅝ */}, {'7', '8', 8542 /* ⅞ */},
	{'1', 'R', 8544 /* Ⅰ */}, {'2', 'R', 8545 /* Ⅱ */}, {'3', 'R', 8546 /* Ⅲ */},
	{'4', 'R', 8547 /* Ⅳ */}, {'5', 'R', 8548 /* Ⅴ */}, {'6', 'R', 8549 /* Ⅵ */},
	{'7', 'R', 8550 /* Ⅶ */}, {'8', 'R', 8551 /* Ⅷ */}, {'9', 'R', 8552 /* Ⅸ */},
	{'a', 'R', 8553 /* Ⅹ */}, {'b', 'R', 8554 /* Ⅺ */}, {'c', 'R', 8555 /* Ⅻ */},
	{'1', 'r', 8560 /* ⅰ */}, {'2', 'r', 8561 /* ⅱ */}, {'3', 'r', 8562 /* ⅲ */},
	{'4', 'r', 8563 /* ⅳ */}, {'5', 'r', 8564 /* ⅴ */}, {'6', 'r', 8565 /* ⅵ */},
	{'7', 'r', 8566 /* ⅶ */}, {'8', 'r', 8567 /* ⅷ */}, {'9', 'r', 8568 /* ⅸ */},
	{'a', 'r', 8569 /* ⅹ */}, {'b', 'r', 8570 /* ⅺ */}, {'c', 'r', 8571 /* ⅻ */},
	{'<', '-', 8592 /* ← */}, {'-', '!', 8593 /* ↑ */}, {'-', '>', 8594 /* → */},
	{'-', 'v', 8595 /* ↓ */}, {'<', '>', 8596 /* ↔ */}, {'U', 'D', 8597 /* ↕ */},
	{'<', '=', 8656 /* ⇐ */}, {'=', '>', 8658 /* ⇒ */}, {'=', '=', 8660 /* ⇔ */},
	{'F', 'A', 8704 /* ∀ */}, {'d', 'P', 8706 /* ∂ */}, {'T', 'E', 8707 /* ∃ */},
	{'/', '0', 8709 /* ∅ */}, {'D', 'E', 8710 /* ∆ */}, {'N', 'B', 8711 /* ∇ */},
	{'(', '-', 8712 /* ∈ */}, {'-', ')', 8715 /* ∋ */}, {'*', 'P', 8719 /* ∏ */},
	{'+', 'Z', 8721 /* ∑ */}, {'-', '2', 8722 /* − */}, {'-', '+', 8723 /* ∓ */},
	{'*', '-', 8727 /* ∗ */}, {'O', 'b', 8728 /* ∘ */}, {'S', 'b', 8729 /* ∙ */},
	{'R', 'T', 8730 /* √ */}, {'0', '(', 8733 /* ∝ */}, {'0', '0', 8734 /* ∞ */},
	{'-', 'L', 8735 /* ∟ */}, {'-', 'V', 8736 /* ∠ */}, {'P', 'P', 8741 /* ∥ */},
	{'A', 'N', 8743 /* ∧ */}, {'O', 'R', 8744 /* ∨ */}, {'(', 'U', 8745 /* ∩ */},
	{')', 'U', 8746 /* ∪ */}, {'I', 'n', 8747 /* ∫ */}, {'D', 'I', 8748 /* ∬ */},
	{'I', 'o', 8750 /* ∮ */}, {'.', ':', 8756 /* ∴ */}, {':', '.', 8757 /* ∵ */},
	{':', 'R', 8758 /* ∶ */}, {':', ':', 8759 /* ∷ */}, {'?', '1', 8764 /* ∼ */},
	{'C', 'G', 8766 /* ∾ */}, {'?', '-', 8771 /* ≃ */}, {'?', '=', 8773 /* ≅ */},
	{'?', '2', 8776 /* ≈ */}, {'=', '?', 8780 /* ≌ */}, {'H', 'I', 8787 /* ≓ */},
	{'!', '=', 8800 /* ≠ */}, {'=', '3', 8801 /* ≡ */}, {'=', '<', 8804 /* ≤ */},
	{'>', '=', 8805 /* ≥ */}, {'<', '*', 8810 /* ≪ */}, {'*', '>', 8811 /* ≫ */},
	{'!', '<', 8814 /* ≮ */}, {'!', '>', 8815 /* ≯ */}, {'(', 'C', 8834 /* ⊂ */},
	{')', 'C', 8835 /* ⊃ */}, {'(', '_', 8838 /* ⊆ */}, {')', '_', 8839 /* ⊇ */},
	{'0', '.', 8857 /* ⊙ */}, {'0', '2', 8858 /* ⊚ */}, {'-', 'T', 8869 /* ⊥ */},
	{'.', 'P', 8901 /* ⋅ */}, {':', '3', 8942 /* ⋮ */}, {'.', '3', 8943 /* ⋯ */},
	{'E', 'h', 8962 /* ⌂ */}, {'<', '7', 8968 /* ⌈ */}, {'>', '7', 8969 /* ⌉ */},
	{'7', '<', 8970 /* ⌊ */}, {'7', '>', 8971 /* ⌋ */}, {'N', 'I', 8976 /* ⌐ */},
	{'(', 'A', 8978 /* ⌒ */}, {'T', 'R', 8981 /* ⌕ */}, {'I', 'u', 8992 /* ⌠ */},
	{'I', 'l', 8993 /* ⌡ */}, {'<', '/', 9001 /* 〈 */}, {'/', '>', 9002 /* 〉 */},
	{'V', 's', 9251 /* ␣ */}, {'1', 'h', 9280 /* ⑀ */}, {'3', 'h', 9281 /* ⑁ */},
	{'2', 'h', 9282 /* ⑂ */}, {'4', 'h', 9283 /* ⑃ */}, {'1', 'j', 9286 /* ⑆ */},
	{'2', 'j', 9287 /* ⑇ */}, {'3', 'j', 9288 /* ⑈ */}, {'4', 'j', 9289 /* ⑉ */},
	{'1', '.', 9352 /* ⒈ */}, {'2', '.', 9353 /* ⒉ */}, {'3', '.', 9354 /* ⒊ */},
	{'4', '.', 9355 /* ⒋ */}, {'5', '.', 9356 /* ⒌ */}, {'6', '.', 9357 /* ⒍ */},
	{'7', '.', 9358 /* ⒎ */}, {'8', '.', 9359 /* ⒏ */}, {'9', '.', 9360 /* ⒐ */},
	{'h', 'h', 9472 /* ─ */}, {'H', 'H', 9473 /* ━ */}, {'v', 'v', 9474 /* │ */},
	{'V', 'V', 9475 /* ┃ */}, {'3', '-', 9476 /* ┄ */}, {'3', '_', 9477 /* ┅ */},
	{'3', '!', 9478 /* ┆ */}, {'3', '/', 9479 /* ┇ */}, {'4', '-', 9480 /* ┈ */},
	{'4', '_', 9481 /* ┉ */}, {'4', '!', 9482 /* ┊ */}, {'4', '/', 9483 /* ┋ */},
	{'d', 'r', 9484 /* ┌ */}, {'d', 'R', 9485 /* ┍ */}, {'D', 'r', 9486 /* ┎ */},
	{'D', 'R', 9487 /* ┏ */}, {'d', 'l', 9488 /* ┐ */}, {'d', 'L', 9489 /* ┑ */},
	{'D', 'l', 9490 /* ┒ */}, {'L', 'D', 9491 /* ┓ */}, {'u', 'r', 9492 /* └ */},
	{'u', 'R', 9493 /* ┕ */}, {'U', 'r', 9494 /* ┖ */}, {'U', 'R', 9495 /* ┗ */},
	{'u', 'l', 9496 /* ┘ */}, {'u', 'L', 9497 /* ┙ */}, {'U', 'l', 9498 /* ┚ */},
	{'U', 'L', 9499 /* ┛ */}, {'v', 'r', 9500 /* ├ */}, {'v', 'R', 9501 /* ┝ */},
	{'V', 'r', 9504 /* ┠ */}, {'V', 'R', 9507 /* ┣ */}, {'v', 'l', 9508 /* ┤ */},
	{'v', 'L', 9509 /* ┥ */}, {'V', 'l', 9512 /* ┨ */}, {'V', 'L', 9515 /* ┫ */},
	{'d', 'h', 9516 /* ┬ */}, {'d', 'H', 9519 /* ┯ */}, {'D', 'h', 9520 /* ┰ */},
	{'D', 'H', 9523 /* ┳ */}, {'u', 'h', 9524 /* ┴ */}, {'u', 'H', 9527 /* ┷ */},
	{'U', 'h', 9528 /* ┸ */}, {'U', 'H', 9531 /* ┻ */}, {'v', 'h', 9532 /* ┼ */},
	{'v', 'H', 9535 /* ┿ */}, {'V', 'h', 9538 /* ╂ */}, {'V', 'H', 9547 /* ╋ */},
	{'F', 'D', 9585 /* ╱ */}, {'B', 'D', 9586 /* ╲ */}, {'T', 'B', 9600 /* ▀ */},
	{'L', 'B', 9604 /* ▄ */}, {'F', 'B', 9608 /* █ */}, {'l', 'B', 9612 /* ▌ */},
	{'R', 'B', 9616 /* ▐ */}, {'.', 'S', 9617 /* ░ */}, {':', 'S', 9618 /* ▒ */},
	{'?', 'S', 9619 /* ▓ */}, {'f', 'S', 9632 /* ■ */}, {'O', 'S', 9633 /* □ */},
	{'R', 'O', 9634 /* ▢ */}, {'R', 'r', 9635 /* ▣ */}, {'R', 'F', 9636 /* ▤ */},
	{'R', 'Y', 9637 /* ▥ */}, {'R', 'H', 9638 /* ▦ */}, {'R', 'Z', 9639 /* ▧ */},
	{'R', 'K', 9640 /* ▨ */}, {'R', 'X', 9641 /* ▩ */}, {'s', 'B', 9642 /* ▪ */},
	{'S', 'R', 9644 /* ▬ */}, {'O', 'r', 9645 /* ▭ */}, {'U', 'T', 9650 /* ▲ */},
	{'u', 'T', 9651 /* △ */}, {'P', 'R', 9654 /* ▶ */}, {'T', 'r', 9655 /* ▷ */},
	{'D', 't', 9660 /* ▼ */}, {'d', 'T', 9661 /* ▽ */}, {'P', 'L', 9664 /* ◀ */},
	{'T', 'l', 9665 /* ◁ */}, {'D', 'b', 9670 /* ◆ */}, {'D', 'w', 9671 /* ◇ */},
	{'L', 'Z', 9674 /* ◊ */}, {'0', 'm', 9675 /* ○ */}, {'0', 'o', 9678 /* ◎ */},
	{'0', 'M', 9679 /* ● */}, {'0', 'L', 9680 /* ◐ */}, {'0', 'R', 9681 /* ◑ */},
	{'S', 'n', 9688 /* ◘ */}, {'I', 'c', 9689 /* ◙ */}, {'F', 'd', 9698 /* ◢ */},
	{'B', 'd', 9699 /* ◣ */}, {'*', '2', 9733 /* ★ */}, {'*', '1', 9734 /* ☆ */},
	{'<', 'H', 9756 /* ☜ */}, {'>', 'H', 9758 /* ☞ */}, {'0', 'u', 9786 /* ☺ */},
	{'0', 'U', 9787 /* ☻ */}, {'S', 'U', 9788 /* ☼ */}, {'F', 'm', 9792 /* ♀ */},
	{'M', 'l', 9794 /* ♂ */}, {'c', 'S', 9824 /* ♠ */}, {'c', 'H', 9825 /* ♡ */},
	{'c', 'D', 9826 /* ♢ */}, {'c', 'C', 9827 /* ♣ */}, {'M', 'd', 9833 /* ♩ */},
	{'M', '8', 9834 /* ♪ */}, {'M', '2', 9835 /* ♫ */}, {'M', 'b', 9837 /* ♭ */},
	{'M', 'x', 9838 /* ♮ */}, {'M', 'X', 9839 /* ♯ */}, {'O', 'K', 10003 /* ✓ */},
	{'X', 'X', 10007 /* ✗ */}, {'-', 'X', 10016 /* ✠ */}, {'I', 'S', 12288 /* 　 */},
	{',', '_', 12289 /* 、*/}, {'.', '_', 12290 /* 。 */}, {'+', '"', 12291 /* 〃 */},
	{'+', '_', 12292 /* 〄 */}, {'*', '_', 12293 /* 々 */}, {';', '_', 12294 /* 〆 */},
	{'0', '_', 12295 /* 〇 */}, {'<', '+', 12298 /* 《 */}, {'>', '+', 12299 /* 》 */},
	{'<', '\'', 12300 /* 「 */}, {'>', '\'', 12301 /* 」 */}, {'<', '"', 12302 /* 『 */},
	{'>', '"', 12303 /* 』 */}, {'(', '"', 12304 /* 【 */}, {')', '"', 12305 /* 】 */},
	{'=', 'T', 12306 /* 〒 */}, {'=', '_', 12307 /* 〓 */}, {'(', '\'', 12308 /* 〔 */},
	{')', '\'', 12309 /* 〕 */}, {'(', 'I', 12310 /* 〖 */}, {')', 'I', 12311 /* 〗 */},
	{'-', '?', 12316 /* 〜 */}, {'A', '5', 12353 /* ぁ */}, {'a', '5', 12354 /* あ */},
	{'I', '5', 12355 /* ぃ */}, {'i', '5', 12356 /* い */}, {'U', '5', 12357 /* ぅ */},
	{'u', '5', 12358 /* う */}, {'E', '5', 12359 /* ぇ */}, {'e', '5', 12360 /* え */},
	{'O', '5', 12361 /* ぉ */}, {'o', '5', 12362 /* お */}, {'k', 'a', 12363 /* か */},
	{'g', 'a', 12364 /* が */}, {'k', 'i', 12365 /* き */}, {'g', 'i', 12366 /* ぎ */},
	{'k', 'u', 12367 /* く */}, {'g', 'u', 12368 /* ぐ */}, {'k', 'e', 12369 /* け */},
	{'g', 'e', 12370 /* げ */}, {'k', 'o', 12371 /* こ */}, {'g', 'o', 12372 /* ご */},
	{'s', 'a', 12373 /* さ */}, {'z', 'a', 12374 /* ざ */}, {'s', 'i', 12375 /* し */},
	{'z', 'i', 12376 /* じ */}, {'s', 'u', 12377 /* す */}, {'z', 'u', 12378 /* ず */},
	{'s', 'e', 12379 /* せ */}, {'z', 'e', 12380 /* ぜ */}, {'s', 'o', 12381 /* そ */},
	{'z', 'o', 12382 /* ぞ */}, {'t', 'a', 12383 /* た */}, {'d', 'a', 12384 /* だ */},
	{'t', 'i', 12385 /* ち */}, {'d', 'i', 12386 /* ぢ */}, {'t', 'U', 12387 /* っ */},
	{'t', 'u', 12388 /* つ */}, {'d', 'u', 12389 /* づ */}, {'t', 'e', 12390 /* て */},
	{'d', 'e', 12391 /* で */}, {'t', 'o', 12392 /* と */}, {'d', 'o', 12393 /* ど */},
	{'n', 'a', 12394 /* な */}, {'n', 'i', 12395 /* に */}, {'n', 'u', 12396 /* ぬ */},
	{'n', 'e', 12397 /* ね */}, {'n', 'o', 12398 /* の */}, {'h', 'a', 12399 /* は */},
	{'b', 'a', 12400 /* ば */}, {'p', 'a', 12401 /* ぱ */}, {'h', 'i', 12402 /* ひ */},
	{'b', 'i', 12403 /* び */}, {'p', 'i', 12404 /* ぴ */}, {'h', 'u', 12405 /* ふ */},
	{'b', 'u', 12406 /* ぶ */}, {'p', 'u', 12407 /* ぷ */}, {'h', 'e', 12408 /* へ */},
	{'b', 'e', 12409 /* べ */}, {'p', 'e', 12410 /* ぺ */}, {'h', 'o', 12411 /* ほ */},
	{'b', 'o', 12412 /* ぼ */}, {'p', 'o', 12413 /* ぽ */}, {'m', 'a', 12414 /* ま */},
	{'m', 'i', 12415 /* み */}, {'m', 'u', 12416 /* む */}, {'m', 'e', 12417 /* め */},
	{'m', 'o', 12418 /* も */}, {'y', 'A', 12419 /* ゃ */}, {'y', 'a', 12420 /* や */},
	{'y', 'U', 12421 /* ゅ */}, {'y', 'u', 12422 /* ゆ */}, {'y', 'O', 12423 /* ょ */},
	{'y', 'o', 12424 /* よ */}, {'r', 'a', 12425 /* ら */}, {'r', 'i', 12426 /* り */},
	{'r', 'u', 12427 /* る */}, {'r', 'e', 12428 /* れ */}, {'r', 'o', 12429 /* ろ */},
	{'w', 'A', 12430 /* ゎ */}, {'w', 'a', 12431 /* わ */}, {'w', 'i', 12432 /* ゐ */},
	{'w', 'e', 12433 /* ゑ */}, {'w', 'o', 12434 /* を */}, {'n', '5', 12435 /* ん */},
	{'v', 'u', 12436 /* ゔ */}, {'"', '5', 12443 /* ゛ */}, {'0', '5', 12444 /* ゜ */},
	{'*', '5', 12445 /* ゝ */}, {'+', '5', 12446 /* ゞ */}, {'a', '6', 12449 /* ァ */},
	{'A', '6', 12450 /* ア */}, {'i', '6', 12451 /* ィ */}, {'I', '6', 12452 /* イ */},
	{'u', '6', 12453 /* ゥ */}, {'U', '6', 12454 /* ウ */}, {'e', '6', 12455 /* ェ */},
	{'E', '6', 12456 /* エ */}, {'o', '6', 12457 /* ォ */}, {'O', '6', 12458 /* オ */},
	{'K', 'a', 12459 /* カ */}, {'G', 'a', 12460 /* ガ */}, {'K', 'i', 12461 /* キ */},
	{'G', 'i', 12462 /* ギ */}, {'K', 'u', 12463 /* ク */}, {'G', 'u', 12464 /* グ */},
	{'K', 'e', 12465 /* ケ */}, {'G', 'e', 12466 /* ゲ */}, {'K', 'o', 12467 /* コ */},
	{'G', 'o', 12468 /* ゴ */}, {'S', 'a', 12469 /* サ */}, {'Z', 'a', 12470 /* ザ */},
	{'S', 'i', 12471 /* シ */}, {'Z', 'i', 12472 /* ジ */}, {'S', 'u', 12473 /* ス */},
	{'Z', 'u', 12474 /* ズ */}, {'S', 'e', 12475 /* セ */}, {'Z', 'e', 12476 /* ゼ */},
	{'S', 'o', 12477 /* ソ */}, {'Z', 'o', 12478 /* ゾ */}, {'T', 'a', 12479 /* タ */},
	{'D', 'a', 12480 /* ダ */}, {'T', 'i', 12481 /* チ */}, {'D', 'i', 12482 /* ヂ */},
	{'T', 'U', 12483 /* ッ */}, {'T', 'u', 12484 /* ツ */}, {'D', 'u', 12485 /* ヅ */},
	{'T', 'e', 12486 /* テ */}, {'D', 'e', 12487 /* デ */}, {'T', 'o', 12488 /* ト */},
	{'D', 'o', 12489 /* ド */}, {'N', 'a', 12490 /* ナ */}, {'N', 'i', 12491 /* ニ */},
	{'N', 'u', 12492 /* ヌ */}, {'N', 'e', 12493 /* ネ */}, {'N', 'o', 12494 /* ノ */},
	{'H', 'a', 12495 /* ハ */}, {'B', 'a', 12496 /* バ */}, {'P', 'a', 12497 /* パ */},
	{'H', 'i', 12498 /* ヒ */}, {'B', 'i', 12499 /* ビ */}, {'P', 'i', 12500 /* ピ */},
	{'H', 'u', 12501 /* フ */}, {'B', 'u', 12502 /* ブ */}, {'P', 'u', 12503 /* プ */},
	{'H', 'e', 12504 /* ヘ */}, {'B', 'e', 12505 /* ベ */}, {'P', 'e', 12506 /* ペ */},
	{'H', 'o', 12507 /* ホ */}, {'B', 'o', 12508 /* ボ */}, {'P', 'o', 12509 /* ポ */},
	{'M', 'a', 12510 /* マ */}, {'M', 'i', 12511 /* ミ */}, {'M', 'u', 12512 /* ム */},
	{'M', 'e', 12513 /* メ */}, {'M', 'o', 12514 /* モ */}, {'Y', 'A', 12515 /* ャ */},
	{'Y', 'a', 12516 /* ヤ */}, {'Y', 'U', 12517 /* ュ */}, {'Y', 'u', 12518 /* ユ */},
	{'Y', 'O', 12519 /* ョ */}, {'Y', 'o', 12520 /* ヨ */}, {'R', 'a', 12521 /* ラ */},
	{'R', 'i', 12522 /* リ */}, {'R', 'u', 12523 /* ル */}, {'R', 'e', 12524 /* レ */},
	{'R', 'o', 12525 /* ロ */}, {'W', 'A', 12526 /* ヮ */}, {'W', 'a', 12527 /* ワ */},
	{'W', 'i', 12528 /* ヰ */}, {'W', 'e', 12529 /* ヱ */}, {'W', 'o', 12530 /* ヲ */},
	{'N', '6', 12531 /* ン */}, {'V', 'u', 12532 /* ヴ */}, {'K', 'A', 12533 /* ヵ */},
	{'K', 'E', 12534 /* ヶ */}, {'V', 'a', 12535 /* ヷ */}, {'V', 'i', 12536 /* ヸ */},
	{'V', 'e', 12537 /* ヹ */}, {'V', 'o', 12538 /* ヺ */}, {'.', '6', 12539 /* ・ */},
	{'-', '6', 12540 /* ー */}, {'*', '6', 12541 /* ヽ */}, {'+', '6', 12542 /* ヾ */},
	{'b', '4', 12549 /* ㄅ */}, {'p', '4', 12550 /* ㄆ */}, {'m', '4', 12551 /* ㄇ */},
	{'f', '4', 12552 /* ㄈ */}, {'d', '4', 12553 /* ㄉ */}, {'t', '4', 12554 /* ㄊ */},
	{'n', '4', 12555 /* ㄋ */}, {'l', '4', 12556 /* ㄌ */}, {'g', '4', 12557 /* ㄍ */},
	{'k', '4', 12558 /* ㄎ */}, {'h', '4', 12559 /* ㄏ */}, {'j', '4', 12560 /* ㄐ */},
	{'q', '4', 12561 /* ㄑ */}, {'x', '4', 12562 /* ㄒ */}, {'z', 'h', 12563 /* ㄓ */},
	{'c', 'h', 12564 /* ㄔ */}, {'s', 'h', 12565 /* ㄕ */}, {'r', '4', 12566 /* ㄖ */},
	{'z', '4', 12567 /* ㄗ */}, {'c', '4', 12568 /* ㄘ */}, {'s', '4', 12569 /* ㄙ */},
	{'a', '4', 12570 /* ㄚ */}, {'o', '4', 12571 /* ㄛ */}, {'e', '4', 12572 /* ㄜ */},
	{'a', 'i', 12574 /* ㄞ */}, {'e', 'i', 12575 /* ㄟ */}, {'a', 'u', 12576 /* ㄠ */},
	{'o', 'u', 12577 /* ㄡ */}, {'a', 'n', 12578 /* ㄢ */}, {'e', 'n', 12579 /* ㄣ */},
	{'a', 'N', 12580 /* ㄤ */}, {'e', 'N', 12581 /* ㄥ */}, {'e', 'r', 12582 /* ㄦ */},
	{'i', '4', 12583 /* ㄧ */}, {'u', '4', 12584 /* ㄨ */}, {'i', 'u', 12585 /* ㄩ */},
	{'v', '4', 12586 /* ㄪ */}, {'n', 'G', 12587 /* ㄫ */}, {'g', 'n', 12588 /* ㄬ */},
	{'1', 'c', 12832 /* ㈠ */}, {'2', 'c', 12833 /* ㈡ */}, {'3', 'c', 12834 /* ㈢ */},
	{'4', 'c', 12835 /* ㈣ */}, {'5', 'c', 12836 /* ㈤ */}, {'6', 'c', 12837 /* ㈥ */},
	{'7', 'c', 12838 /* ㈦ */}, {'8', 'c', 12839 /* ㈧ */}, {'9', 'c', 12840 /* ㈨ */},
	{'f', 'f', 64256 /* ﬀ */}, {'f', 'i', 64257 /* ﬁ */}, {'f', 'l', 64258 /* ﬂ */},
	{'f', 't', 64261 /* ﬅ */}, {'s', 't', 64262 /* ﬆ */},
}

func (s *State) writeStrWrap(str []rune) {
	buf := make([]rune, 0, len(str))
	for i, c := range str {
		if _ASCII_TAB == c {
			n := (8 - s.cx%8)
			if int(s.ws.Col) < s.cx+n {
				for n := 0; int(s.ws.Col)-s.cx > n; n++ {
					buf = append(buf, ' ')
				}
				s.cx = int(s.ws.Col)
			} else {
				s.cx += n
				for ; n > 0; n-- {
					buf = append(buf, ' ')
				}
			}
		} else {
			rs := runeDisplaySize(c)
			if int(s.ws.Col) < s.cx+rs {
				for n := 0; int(s.ws.Col)-s.cx > n; n++ {
					buf = append(buf, ' ')
				}
				s.cx = int(s.ws.Col)
			}
			d := decode(c)
			buf = append(buf, d...)
			s.cx += rs
		}
		if int(s.ws.Col) <= s.cx {
			s.cx -= int(s.ws.Col)
			s.cy++
			if s.promptLines == s.cy {
				s.promptLines++
			}
			// the terminal wait for the next emitted character to advance line
			// instead of trying to handle this special case everywhere else we just force the scroll
			if len(str)-1 == i {
				buf = append(buf, []rune(" \b")...)
			}
		}
	}
	fmt.Printf("%s", string(buf))
}

func (s *State) writeStrNoWrap(str []rune) bool {
	buf := make([]rune, 0, len(str))
	trunc := false
	for _, c := range str {
		if _ASCII_TAB == c {
			n := 8 - (s.cx % 8)
			if int(s.ws.Col) <= s.cx+n {
				n = int(s.ws.Col) - s.cx
				trunc = true
			}
			s.cx += n
			for ; n > 0; n-- {
				buf = append(buf, ' ')
			}
			if trunc {
				break
			}
		} else {
			d := decode(c)
			buf = append(buf, d...)
			s.cx += runeDisplaySize(c)
			if int(s.ws.Col) <= s.cx {
				buf = buf[:len(buf)-(s.cx-int(s.ws.Col))]
				s.cx = int(s.ws.Col) - 1
				trunc = true
				break
			}
		}
	}
	return writeStrNoWrapInternal(buf, trunc)
}

func (s *State) Close() error {
	var err error
	if s.needsReset {
		err = s.resetTerm()
	}
	return err
}

func (s *State) ReadHistory(r io.Reader) (num int, err error) {
	in := bufio.NewReader(r)
	n := 0
	for {
		item, prefix, err := in.ReadLine()
		if io.EOF == err {
			break
		} else if nil != err {
			return n, err
		} else if prefix {
			return n, fmt.Errorf("line %d is too long", n+1)
		} else if !utf8.Valid(item) {
			return n, fmt.Errorf("invalid string at line %d", n+1)
		}
		if pliner.HistoryLimit <= len(s.history) {
			s.history = s.history[1:]
		}
		s.history = append(s.history, string(item))
		n++
	}
	return n, nil
}

func (s *State) WriteHistory(w io.Writer) (int, error) {
	for i, item := range s.history {
		// can't retain embedded newline characters for compatibility with peterh/liner
		_, err := fmt.Fprintln(w, strings.ReplaceAll(item, "\n", " "))
		if nil != err {
			return i, err
		}
	}
	return len(s.history), nil
}

func (s *State) AppendHistory(item string) {
	if 0 < len(s.history) && item == s.history[len(s.history)-1] {
		return
	}
	if pliner.HistoryLimit <= len(s.history) {
		s.history = s.history[1:]
	}
	s.history = append(s.history, item)
}

func (s *State) ClearHistory() {
	for i, _ := range s.history {
		s.history[i] = ""
	}
	s.history = s.history[:0]
}

func (s *State) SetCtrlCAborts(aborts bool) {
	s.interruptAborts = aborts
}

func (s *State) SetMultiLineMode(mlmode bool) {
	s.multiLine = mlmode
}

// these persist across invocations in contrast to shell-vi-mode equivalents in order to help with repeated statement invocations
var fact, fr rune
var curHist int = -1
var searchForwards bool = true
var search []rune

func (s *State) Prompt(prompt string) (string, error) {
	if s.pipeIn {
		if nil != s.r {
			// don't do anything other than read a line and return it
			l, _, err := s.r.ReadLine()
			if nil != err {
				return "", err
			} else {
				return string(l), nil
			}
			return "", errors.New("vliner: internal error")
		}
	}
	// we don't support non-terminal output
	if s.pipeOut {
		return "", errors.New("vliner: error - not terminal output")
	}

	s.buffer = s.buffer[:0]
	err := s.startTerm()
	if nil != err {
		return "", err
	}
	defer s.resetTerm()

	s.promptLines = 1
	s.cy = 0
	s.cx = 0
	s.replayActive = false

	mode := _NORMAL
	pos := 0
	s.displayStartPos = 0
	i := 0
	repeat := 0
	startPos := 0
	expandEnd := false
	res := 0
	var yank []rune
	var input []rune

	line := make([]rune, 0, 1024)
	line = line[:0]
	s.insertIntoInput('i') // initiate insert mode directly

	cmdPrompt := strings.ToUpper(prompt)
	if cmdPrompt == prompt {
		if len(cmdPrompt) > 3 {
			cmdPrompt = "CMD" + cmdPrompt[3:]
		} else {
			cmdPrompt = "CMD> "
		}
	}

	done := 0
mainLoop:
	for 0 == done {
		// It is simpler when dealing with multiple display character runes to draw the entire input & calculate the cursor
		// position every time
		s.render(pos, cmdPrompt, line, []rune(nil))

		r, err := s.read()
		if nil != err {
			return "", err
		}
		if _REPLAY_END == r {
			s.replayActive = false
			continue
		} else {
			s.record(r)
		}
		if '0' != r && unicode.IsDigit(r) {
			repeat = 0
			for unicode.IsDigit(r) {
				repeat *= 10
				repeat += int(r - '0')
				r, err = s.read()
				if nil != err {
					return "", err
				}
				s.record(r)
			}
			if _ASCII_ESC == r {
				s.replayActive = false
				s.cmdRepeat = s.cmdRepeat[:0]
				continue
			}
			if 100000 < repeat {
				repeat = 100000
			} else if 0 == repeat {
				repeat = 1
			}
		} else if _NORMAL == mode {
			repeat = 1
		}
		if s.controlChars[ccVINTR] == r { // Ctrl+C typically
			line = line[:0]
			pos = 0
			if s.interruptAborts {
				done = 3
				break mainLoop
			}
		} else if s.controlChars[ccVEOF] == r { // Ctrl+D typically
			done = 2
			break mainLoop
		}
		if _NORMAL == mode {
			handled := true
			switch r {
			case '.':
				s.insertStringIntoInput(append(s.cmdRepeat, _REPLAY_END))
				s.replayActive = true
			case 'C':
				s.saveForUndo(line, pos, repeat, r)
				mode = _CHANGE
				startPos = len(line)
				repeat = 1
			case 'c':
				s.saveForUndo(line, pos, repeat, r)
				mode = _CHANGE_SELECTED
				startPos = pos
			case 'D':
				s.saveForUndo(line, pos, repeat, r)
				mode = _DELETE
				startPos = len(line)
				repeat = 1
			case 'd':
				s.saveForUndo(line, pos, repeat, r)
				mode = _DELETE_SELECTED
				startPos = pos
			case 'Y':
				mode = _YANK
				expandEnd = true
				startPos = pos
				pos = len(line)
				if 0 < pos {
					pos--
				}
			case 'y':
				mode = _YANK_SELECTED
				startPos = pos
			// history ------------------------------------------
			case 'k':
				fallthrough
			case '-':
				pos = 0
				if -1 == curHist {
					s.save = append(s.save[:0], line...)
					s.savePos = 0
					curHist = len(s.history)
				}
				if 0 < curHist {
					curHist -= repeat
					if 0 > curHist {
						curHist = 0
					}
					line = line[:0]
					if len(s.history) > curHist {
						line = insertRunes(line, 0, []rune(s.history[curHist]))
					}
				}
			case 'j':
				fallthrough
			case '+':
				pos = 0
				if -1 == curHist {
					s.save = append(s.save[:0], line...)
					s.savePos = 0
					curHist = len(s.history)
				} else {
					curHist += repeat
				}
				if curHist >= len(s.history) {
					line = line[:0]
					line = insertRunes(line, 0, []rune(s.save))
					curHist = -1
				} else {
					line = line[:0]
					if len(s.history) > curHist {
						line = insertRunes(line, 0, []rune(s.history[curHist]))
					}
				}
			case '/':
				if 0 == len(s.history) {
					break
				}
				search, res = s.inputText("/", []rune(""), []rune(""), true)
				if -1 == res {
					return "", errors.New("vliner: failed to input text")
				} else if 0 == res || 0 == len(search) {
					break
				}
				i = s.searchHistory(len(s.history)-1, -1, string(search), repeat)
				if -1 == i {
					break
				}
				if -1 == curHist {
					s.save = append(s.save[:0], line...)
					s.savePos = 0
				}
				line = insertRunes(line[:0], 0, []rune(s.history[i]))
				curHist = i
				pos = 0
				searchForwards = true
			case '?':
				if 0 == len(s.history) {
					break
				}
				search, res = s.inputText("?", []rune(""), []rune(""), true)
				if -1 == res {
					return "", errors.New("vliner: failed to input text")
				} else if 0 == res || 0 == len(search) {
					break
				}
				i = s.searchHistory(0, len(s.history), string(search), repeat)
				if -1 == i {
					break
				}
				if -1 == curHist {
					s.save = append(s.save[:0], line...)
					s.savePos = 0
				}
				line = insertRunes(line[:0], 0, []rune(s.history[i]))
				curHist = i
				pos = 0
				searchForwards = false
			case 'n':
				if 0 == len(s.history) || 0 == len(search) {
					break
				}
				if searchForwards {
					if 0 == curHist {
						break
					} else if -1 == curHist {
						curHist = len(s.history)
					}
					i = s.searchHistory(curHist-1, -1, string(search), repeat)
				} else {
					if len(s.history) <= curHist+1 {
						break
					}
					i = s.searchHistory(curHist+1, len(s.history), string(search), repeat)
				}
				if -1 == i {
					break
				}
				line = insertRunes(line[:0], 0, []rune(s.history[i]))
				curHist = i
				pos = 0
			case 'N':
				if 0 == len(s.history) || 0 == len(search) {
					break
				}
				if !searchForwards {
					if 0 == curHist {
						break
					} else if -1 == curHist {
						curHist = len(s.history)
					}
					i = s.searchHistory(curHist-1, -1, string(search), repeat)
				} else {
					if len(s.history) <= curHist+1 {
						break
					}
					i = s.searchHistory(curHist+1, len(s.history), string(search), repeat)
				}
				if -1 == i {
					break
				}
				line = insertRunes(line[:0], 0, []rune(s.history[i]))
				curHist = i
				pos = 0
			case 'G':
				if 0 == len(s.history) {
					break
				}
				if len(s.history) < repeat {
					break
				}
				if -1 == curHist {
					s.save = append(s.save[:0], line...)
					s.savePos = 0
				}
				line = insertRunes(line[:0], 0, []rune(s.history[repeat]))
				curHist = repeat
				pos = 0
			case '_':
				if 0 == len(s.history) {
					break
				}
				n := len(s.history) - 1
				l := len(s.history[n])
				for i = 0; l > i && 0 == classify(rune(s.history[n][i])); i++ {
				}
				if l <= i {
					break
				}
				startPos := i
				for i <= l {
					if 0 == classify(rune(s.history[n][i])) || l == i {
						repeat--
						if 0 == repeat {
							hl := i - startPos
							if 0 < hl {
								if pos < len(line) {
									pos++
								}
								s.saveForUndo(line, pos, repeat, r)
								line = insertRunes(line, pos, append([]rune{' '}, []rune(s.history[n][startPos:startPos+hl])...))
								pos += hl + 1
							}
							if !s.replayActive {
								s.insertIntoInput('i')
							}
							break
						}
						for 0 == classify(rune(s.history[n][i])) {
							i++
						}
						startPos = i
					} else {
						i++
					}
				}
			// editing ------------------------------------------
			case 'P':
				if 0 < len(yank) {
					s.saveForUndo(line, pos, repeat, r)
					for ; 0 < repeat; repeat-- {
						line = insertRunes(line, pos, yank)
					}
				}
				s.stopRecording()
			case 'p':
				if 0 < len(yank) {
					s.saveForUndo(line, pos, repeat, r)
					pos++
					for ; 0 < repeat; repeat-- {
						line = insertRunes(line, pos, yank)
						pos += len(yank)
					}
					pos--
				}
				s.stopRecording()
			case 'S':
				s.saveForUndo(line, pos, repeat, r)
				pos = 0
				line = line[:0]
				if !s.replayActive {
					s.insertIntoInput('i')
				}
			case 's':
				s.saveForUndo(line, pos, repeat, r)
				l := repeat
				if len(line) < pos+l {
					l = len(line) - pos
				}
				yank = append([]rune(nil), line[pos:pos+l]...)
				copy(line[pos:], line[pos+l:])
				line = line[:len(line)-l]
				if !s.replayActive {
					s.insertIntoInput('i')
				}
			case 'u':
				if 1 == repeat&0x1 {
					line, s.save = s.save, line
					pos, s.savePos = s.savePos, pos
				}
			case 'r':
				s.saveForUndo(line, pos, repeat, r)
				r, err = s.read()
				if nil != err {
					return "", err
				}
				s.record(r)
				for ; 0 < repeat && len(line) > pos; repeat-- {
					line[pos] = r
					if 0 != repeat {
						pos++
					}
				}
				s.stopRecording()
			case 'X':
				if repeat > pos {
					repeat = pos
				}
				pos -= repeat
				if 0 > pos {
					pos = 0
				}
				fallthrough
			case 'x':
				s.saveForUndo(line, pos, repeat, r)
				l := repeat
				if len(line) < pos+l {
					l = len(line) - pos
				}
				yank = append([]rune(nil), line[pos:pos+l]...)
				copy(line[pos:], line[pos+l:])
				line = line[:len(line)-l]
				if len(line) <= pos {
					if 0 == len(line) {
						pos = 0
					} else {
						pos = len(line) - 1
					}
				}
				s.stopRecording()
			case '~':
				s.saveForUndo(line, pos, repeat, r)
				for ; 0 < repeat && len(line) > pos; repeat-- {
					if unicode.IsUpper(line[pos]) {
						line[pos] = unicode.ToLower(line[pos])
					} else if unicode.IsLower(line[pos]) {
						line[pos] = unicode.ToUpper(line[pos])
					}
					pos++
				}
				s.stopRecording()
			case 'A':
				s.saveForUndo(line, pos, repeat, r)
				pos = len(line)
				fallthrough
			case 'a':
				if 'a' == r {
					s.saveForUndo(line, pos, repeat, r)
				}
				if len(line) > pos {
					pos++
				}
				fallthrough
			case 'i':
				if 'i' == r {
					s.saveForUndo(line, pos, repeat, r)
				}
				curHist = -1
				// if replaying we'll use the existing input buffer
				if !s.replayActive {
					prefix := line[:pos]
					suffix := line[pos:]
					input, done = s.inputText(prompt, prefix, suffix, true)
				}
				if len(input) > 0 {
					for ; 0 < repeat; repeat-- {
						line = insertRunes(line, pos, input)
						pos += len(input)
					}
					if 0 < pos {
						pos--
					}
				}
				s.stopRecording()
			case 'I':
				s.saveForUndo(line, pos, repeat, r)
				pos = 0
				for 0 == classify(line[pos]) && len(line) > pos {
					pos++
				}
				if !s.replayActive {
					s.insertIntoInput('i')
				}
			case 'R':
				s.saveForUndo(line, pos, repeat, r)
				curHist = -1
				// if replaying we'll use the existing input buffer
				if !s.replayActive {
					prefix := line[:pos]
					suffix := line[pos:]
					input, done = s.inputText(prompt, prefix, suffix, false)
				}

				if len(input) > 0 {
					l := repeat * len(input)
					if len(line) <= pos+l {
						line = line[:pos]
					} else {
						copy(line[pos:], line[pos+l:])
						line = line[:len(line)-l]
					}
					for ; 0 < repeat; repeat-- {
						line = insertRunes(line, pos, input)
						pos += len(input)
					}
					if 0 < pos {
						pos--
					}
				}
				s.stopRecording()
			default:
				handled = false
			}
			if handled {
				r = 0
			}
		}
		// all modes
		switch r {
		case '\n':
			fallthrough
		case '\r':
			done = 1
			break mainLoop
		case _ASCII_ESC:
			mode = _NORMAL
			s.replayActive = false
			s.stopRecording()
		case 'c':
			if _CHANGE == mode {
				startPos = 0
				pos = len(line)
			}
		case 'd':
			if _DELETE == mode {
				startPos = 0
				pos = len(line)
			}
		// navigation ---------------------------------------
		case '|':
			pos = repeat - 1
			if pos >= len(line) {
				pos = len(line) - 1
			}
			if 0 > pos {
				pos = 0
			}
		case '0':
			pos = 0
		case '^':
			for pos = 0; len(line) > pos && 0 == classify(line[pos]); pos++ {
			}
			if 0 < pos && len(line) == pos {
				pos--
			}
		case '$':
			pos = len(line) - 1
			if _NORMAL != mode {
				pos++
			}
			if 0 > pos {
				pos = 0
			}
		case 'h':
			pos -= repeat
			if 0 > pos {
				pos = 0
			}
		case ' ':
			fallthrough
		case 'l':
			if 0 == len(line) {
				pos = 0
			} else {
				pos += repeat
				if len(line) <= pos {
					pos = len(line) - 1
				}
			}
		case 'B':
			fallthrough
		case 'b':
			if 0 >= pos {
				break
			}
			for ; 0 < repeat; repeat-- {
				pos--
				if 0 >= pos {
					break
				}
				for 0 < pos && 0 == classify(line[pos]) {
					pos--
				}
				if 'B' == r {
					for 0 < pos && 0 != classify(line[pos-1]) {
						pos--
					}
				} else {
					t := classify(line[pos])
					for 0 < pos && t == classify(line[pos-1]) {
						pos--
					}
				}
			}
		case 'E':
			fallthrough
		case 'e':
			if len(line) <= pos {
				break
			}
			for ; 0 < repeat; repeat-- {
				pos++
				if len(line) <= pos {
					pos = len(line) - 1
					break
				}
				for len(line) > pos && 0 == classify(line[pos]) {
					pos++
				}
				if 'E' == r {
					for len(line)-1 > pos && 0 != classify(line[pos+1]) {
						pos++
					}
				} else {
					t := classify(line[pos])
					for len(line)-1 > pos && t == classify(line[pos+1]) {
						pos++
					}
				}
			}
			if _NORMAL != mode {
				pos++
			}
		case 'W':
			fallthrough
		case 'w':
			if len(line) <= pos {
				break
			}
			for ; 0 < repeat; repeat-- {
				t := classify(line[pos])
				pos++
				if len(line) <= pos {
					pos = len(line) - 1
					break
				}
				if 'W' == r {
					for len(line) > pos && 0 != classify(line[pos]) {
						pos++
					}
				} else {
					for len(line) > pos && t == classify(line[pos]) {
						pos++
					}
				}
				for len(line) > pos && 0 == classify(line[pos]) {
					pos++
				}
				if len(line) <= pos {
					pos = len(line) - 1
				}
			}
			if _NORMAL != mode {
				if len(line)-1 == pos {
					pos++
				}
				if _CHANGE == mode {
					pos--
					for ; 0 < pos && 0 == classify(line[pos]); pos-- {
					}
					pos++
				}
			}
		case 'T':
			fallthrough
		case 'F':
			fact = r
			fr, err = s.read()
			if nil != err {
				return "", err
			}
			s.record(fr)
			if _ASCII_ESC == fr {
				break
			}
			i = find(line, pos, false, repeat, fr, fr)
			if -1 != i {
				pos = i
				if 'T' == r {
					pos++
				}
			}
		case 't':
			fallthrough
		case 'f':
			fact = r
			fr, err = s.read()
			if nil != err {
				return "", err
			}
			s.record(fr)
			if _ASCII_ESC == fr {
				break
			}
			i = find(line, pos, true, repeat, fr, fr)
			if -1 != i {
				pos = i
				if 't' == r {
					pos--
				}
				if _NORMAL != mode {
					pos++
				}
			}
		case ';':
			switch fact {
			case 'T':
				fallthrough
			case 'F':
				i = find(line, pos, false, repeat, fr, fr)
				if -1 != i {
					pos = i
					if 'T' == r {
						pos++
					}
				}
			case 't':
				fallthrough
			case 'f':
				i = find(line, pos, true, repeat, fr, fr)
				if -1 != i {
					pos = i
					if 't' == r {
						pos--
					}
					if _NORMAL != mode {
						pos++
					}
				}
			}
		case ',':
			switch fact {
			case 't':
				fallthrough
			case 'f':
				i = find(line, pos, false, repeat, fr, fr)
				if -1 != i {
					pos = i
					if 't' == r {
						pos++
					}
				}
			case 'T':
				fallthrough
			case 'F':
				i = find(line, pos, true, repeat, fr, fr)
				if -1 != i {
					pos = i
					if 'T' == r {
						pos--
					}
					if _NORMAL != mode {
						pos++
					}
				}
			}
		case '%':
			switch line[pos] {
			case '(':
				i = find(line, pos, true, 1, ')', '(')
				if -1 != i && _NORMAL != mode {
					i++
				}
			case '{':
				i = find(line, pos, true, 1, '}', '{')
				if -1 != i && _NORMAL != mode {
					i++
				}
			case '[':
				i = find(line, pos, true, 1, ']', '[')
				if -1 != i && _NORMAL != mode {
					i++
				}
			case ')':
				i = find(line, pos, false, 1, '(', ')')
				if -1 != i && _NORMAL != mode {
					expandEnd = true
				}
			case '}':
				i = find(line, pos, false, 1, '{', '}')
				if -1 != i && _NORMAL != mode {
					expandEnd = true
				}
			case ']':
				i = find(line, pos, false, 1, '[', ']')
				if -1 != i && _NORMAL != mode {
					expandEnd = true
				}
			case '`':
				fallthrough
			case '\'':
				fallthrough
			case '"':
				i = findMatchingQuote(line, pos)
				if -1 != i && _NORMAL != mode {
					expandEnd = true
				}
			default:
				i = -1
			}
			if -1 != i {
				pos = i
			}
		case 0:
			// ignore; explicitly set above
		default:
			fmt.Printf("\a") // ASCII BEL
		}

		switch mode {
		case _CHANGE_SELECTED:
			mode = _CHANGE
		case _DELETE_SELECTED:
			mode = _DELETE
		case _YANK_SELECTED:
			mode = _YANK
			expandEnd = false
		case _DELETE:
			if pos == startPos {
				mode = _NORMAL
				break
			}
			fallthrough
		case _CHANGE:
			if pos == startPos {
				startPos++
			}
			l := 0
			if startPos < pos {
				pos, startPos = startPos, pos
			}
			l = startPos - pos
			yank = append([]rune(nil), line[pos:startPos]...)
			copy(line[pos:], line[startPos:])
			line = line[:len(line)-l]
			if _CHANGE == mode {
				if !s.replayActive {
					s.insertIntoInput('i')
				}
			} else {
				if pos >= len(line) {
					pos = len(line) - 1
					if 0 > pos {
						pos = 0
					}
				}
				s.stopRecording()
			}
			mode = _NORMAL
		case _YANK:
			if pos != startPos {
				if startPos < pos {
					if expandEnd {
						pos++
					}
					yank = append([]rune(nil), line[startPos:pos]...)
				} else {
					if expandEnd {
						startPos++
					}
					yank = append([]rune(nil), line[pos:startPos]...)
					if expandEnd {
						startPos--
					}
				}
				pos = startPos
			}
			mode = _NORMAL
		}
	} // main loop

	s.clearPrompt()
	s.writeStrWrap([]rune(prompt))

	if 2 == done {
		return "", io.EOF
	} else if 1 != done {
		return "", errors.New("vliner: input error")
	}

	s.writeStrWrap(line)
	fmt.Printf("\n")
	return string(line), nil
}

func (s *State) render(pos int, prompt string, input []rune, suffix []rune) {
	var x int
	var i int
	s.hideCursor()
	if !s.multiLine {
		var chlen int
		x = len(prompt)
		for i = s.displayStartPos; pos > i; i++ {
			if _ASCII_TAB == input[i] {
				chlen = 8 - (x % 8)
			} else {
				chlen = runeDisplaySize(input[i])
			}
			x += chlen
		}
		if int(s.ws.Col) <= x || s.displayStartPos > pos {
			s.displayStartPos = 0
			l := len(prompt)
			for _, r := range input[:pos] {
				if _ASCII_TAB == r {
					chlen = 8 - (l % 8)
				} else {
					chlen = runeDisplaySize(r)
				}
				l += chlen
			}
			x = len(prompt)
			for n, r := range input {
				if int(s.ws.Col/2) >= l-x {
					s.displayStartPos = n
					break
				}
				if _ASCII_TAB == r {
					chlen = 8 - (x % 8)
				} else {
					chlen = runeDisplaySize(r)
				}
				x += chlen
			}
			x = len(prompt)
			for i = s.displayStartPos; pos > i; i++ {
				r := input[i]
				if _ASCII_TAB == r {
					chlen = 8 - (x % 8)
				} else {
					chlen = runeDisplaySize(r)
				}
				x += chlen
			}
		}
		s.moveToStart()
		if 0 < len(suffix) {
			if !s.writeStrNoWrap(append(append([]rune(prompt), input[s.displayStartPos:]...), suffix...)) {
				s.clearToEOL()
			}
		} else {
			if !s.writeStrNoWrap(append([]rune(prompt), input[s.displayStartPos:]...)) {
				s.clearToEOL()
			}
		}
		if len(input) > pos && _ASCII_TAB == input[pos] {
			x = x + (8 - x%8) - 1
			if int(s.ws.Col) <= x {
				x = int(s.ws.Col) - 1
			}
		}
		s.moveToCol(x)
	} else {
		s.moveToStart()
		s.writeStrWrap([]rune(prompt))
		s.writeStrWrap(input[:pos])
		kx := s.cx
		ky := s.cy
		if len(input) > pos {
			s.writeStrWrap(input[pos:])
		}
		if 0 < len(suffix) {
			s.writeStrWrap(suffix)
		}
		s.clearToEOP()
		s.moveToStart()
		s.moveDown(ky)
		s.moveRight(kx)
	}
	s.showCursor()
}

func (s *State) inputText(prompt string, prefix []rune, suffix []rune, fixedSuffix bool) ([]rune, int) {
	input := make([]rune, 0, 1024)
	input = input[:0]
	combo := make([]rune, 0, 1024)
	combo = append(combo, prefix...)

	pos := 0
	i := 0

	done := -1
	for done = -1; -1 == done; {
		// It is simpler when dealing with multiple display character runes to draw the entire input & calculate the cursor
		// position every time
		combo = combo[:len(prefix)]
		combo = append(combo, input...)
		if fixedSuffix {
			s.render(len(prefix)+pos, prompt, combo, suffix)
		} else if len(suffix) > pos {
			s.render(len(prefix)+pos, prompt, combo, suffix[pos:])
		} else {
			s.render(len(prefix)+pos, prompt, combo, []rune(nil))
		}

		r, err := s.read()
		if nil != err {
			return nil, -1
		}
		if _REPLAY_END == r {
			continue
		} else if s.controlChars[ccVINTR] == r { // Ctrl+C typically
			input = input[:0]
			if s.interruptAborts {
				done = 2
			} else {
				done = 0
			}
		} else if s.controlChars[ccVLNEXT] == r { // Ctrl+V typically
			// raw character input
			s.setISig(false)
			r, err := s.read()
			if nil != err {
				return nil, -1
			}
			s.setISig(true)
			if unicode.IsDigit(r) {
				dec := make([]rune, 0, 3)
				dec = append(dec, r)
				for i := 0; 2 > i; i++ {
					r, err := s.read()
					if nil != err {
						return nil, -1
					}
					if !unicode.IsDigit(r) {
						s.insertIntoInput(r)
						break
					}
					dec = append(dec, r)
				}
				i, _ := strconv.ParseInt(string(dec), 10, 16)
				r = rune(i)
			} else if 'O' == r || 'o' == r {
				oct := make([]rune, 0, 3)
				for i := 0; 3 > i; i++ {
					r, err := s.read()
					if nil != err {
						return nil, -1
					}
					if '0' > r || '7' < r {
						if 0 < len(oct) {
							s.insertIntoInput(r)
						}
						break
					}
					oct = append(oct, r)
				}
				if 0 < len(oct) {
					i, _ := strconv.ParseInt(string(oct), 8, 16)
					r = rune(i)
				}
			} else if 'X' == r || 'x' == r {
				hex := make([]rune, 0, 2)
				for i := 0; 2 > i; i++ {
					r, err := s.read()
					if nil != err {
						return nil, -1
					}
					if !unicode.IsDigit(r) && !('a' <= r && 'f' >= r) && !('A' <= r && 'F' >= r) {
						if 0 < len(hex) {
							s.insertIntoInput(r)
						}
						break
					}
					hex = append(hex, r)
				}
				if 0 < len(hex) {
					i, _ := strconv.ParseInt(string(hex), 16, 16)
					r = rune(i)
				}
			} else if 'u' == r || 'U' == r {
				l := 0
				if 'u' == r {
					l = 4
				} else {
					l = 8
				}
				hex := make([]rune, 0, l)
				for i := 0; l > i; i++ {
					r, err := s.read()
					if nil != err {
						return nil, -1
					}
					if !unicode.IsDigit(r) && !('a' <= r && 'f' >= r) && !('A' <= r && 'F' >= r) {
						if 0 < len(hex) {
							s.insertIntoInput(r)
						}
						break
					}
					hex = append(hex, r)
				}
				if 0 < len(hex) {
					i, _ := strconv.ParseInt(string(hex), 16, 32)
					r = rune(i)
				}
			}
			input = insertRunes(input, pos, []rune{r})
			pos++
		} else if s.controlChars[ccDigraph] == r { // Ctrl+K typically
			r, err := s.read()
			if nil != err {
				return nil, -1
			}
			r2, err := s.read()
			if nil != err {
				return nil, -1
			}
			found := false
			for _, d := range digraphs {
				if d.first == r && d.second == r2 {
					input = insertRunes(input, pos, []rune{d.result})
					pos++
					found = true
					break
				}
			}
			if !found {
				input = insertRunes(input, pos, []rune{r, r2})
				pos += 2
			}
		} else if s.controlChars[ccVEOF] == r { // Ctrl+D typically
			done = 3
		} else if s.controlChars[ccVERASE] == r { // DEL or BS typically
			if 0 < pos {
				if len(input) != pos {
					copy(input[pos-1:], input[pos:])
				}
				input = input[:pos-1]
				pos--
			}
		} else if s.controlChars[ccVWERASE] == r { // Ctrl+W typically
			i = pos - 1
			for 0 <= i && 0 == classify(input[i]) {
				i--
			}
			if 0 > i {
				i = 0
			}
			n := classify(input[i])
			for 0 <= i && n == classify(input[i]) {
				i--
			}
			i++
			if pos > i {
				copy(input[i:], input[pos:])
				input = input[:len(input)-(pos-i)]
				pos = i
			}
		} else if s.controlChars[ccVKILL] == r { // Ctrl+U typically
			pos = 0
			input = input[:0]
		} else if '\r' == r || '\n' == r {
			done = 1
		} else if _ASCII_ESC == r {
			done = 0
		} else {
			if unicode.IsPrint(r) || unicode.IsSpace(r) {
				input = insertRunes(input, pos, []rune{r})
				pos++
			}
		}
	}
	return input, done
}

// we display control characters as composites so we need to deal with them explicitly
func decode(r rune) []rune {
	if _ASCII_NUL <= r && ' ' > r {
		return []rune{rune('^'), []rune("@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]~_")[r]}
	} else if _ASCII_DEL == r {
		return []rune("^?")
	}
	return []rune{r}
}

func runeDisplaySize(r rune) int {
	switch {
	case (_ASCII_NUL <= r && ' ' > r && _ASCII_TAB != r) || _ASCII_DEL == r:
		return 2
	case 0x100 > r:
		return 1
	default:
		return runewidth.RuneWidth(r)
	}
}

func (s *State) record(r rune) {
	if s.recording && '.' != r {
		s.cmdRepeat = append(s.cmdRepeat, r)
	}
}

func (s *State) stopRecording() {
	if !s.replayActive {
		s.recording = false
	}
}

func (s *State) saveForUndo(line []rune, pos int, repeat int, r rune) {
	if !s.replayActive && !s.recording {
		s.save = append(s.save[:0], line...)
		s.savePos = pos
		s.recording = true
		s.cmdRepeat = []rune(fmt.Sprintf("%d%c", repeat, r))
	}
}

func (s *State) insertIntoInput(r rune) {
	s.buffer = append([]rune{r}, s.buffer...)
}

func (s *State) insertStringIntoInput(rs []rune) {
	t := s.buffer
	s.buffer = rs
	s.buffer = append(s.buffer, t...)
}

// these are the basic groupings we use for movement
func classify(r rune) int {
	switch {
	case unicode.IsSpace(r):
		return 0
	case unicode.IsLetter(r) || '_' == r || unicode.IsNumber(r):
		return 1
	case unicode.IsControl(r):
		return 2
	default:
		return 3
	}
}

func find(line []rune, start int, forwards bool, count int, r rune, pair rune) int {
	var i int
	if 0 >= count || 0 > start {
		return -1
	}
	if !forwards {
		for i = start - 1; 0 <= i; i-- {
			if line[i] == r {
				count--
				if 0 == count {
					break
				}
			} else if r != pair && pair == line[i] {
				count++
			}
		}
		if 0 > i || line[i] != r || 0 != count {
			return -1
		}
	} else {
		for i = start + 1; len(line) > i; i++ {
			if line[i] == r {
				count--
				if 0 == count {
					break
				}
			} else if r != pair && pair == line[i] {
				count++
			}
		}
		if len(line) <= i || line[i] != r || 0 != count {
			return -1
		}
	}
	return i
}

func findMatchingQuote(line []rune, pos int) int {
	q := line[pos]
	nq := 0
	last := -1
	n := 0
	for n = 0; pos > n; n++ {
		if '\\' == line[n] {
			n++
		} else if '\'' == q && pos > n && q == line[n] && q == line[n+1] {
			if n+1 == pos {
				return -1
			}
			n++
		} else if q == line[n] {
			last = n
			nq++
		}
	}
	if '\'' == q && len(line) > pos+1 && pos-1 != last && q == line[pos+1] {
		return -1
	}
	if 0 == nq&0x1 {
		for n++; len(line) > n; n++ {
			if '\\' == line[n] {
				n++
			} else if '\'' == q && len(line)-1 > n && q == line[n] && q == line[n+1] {
				n++
			} else if q == line[n] {
				return n
			}
		}
		return -1
	} else {
		return last
	}
}

func (s *State) searchHistory(from int, to int, pat string, repeat int) int {
	incr := 1
	if from > to {
		incr = -1
	}
	found := false

	begin := ('^' == pat[0])
	if begin {
		pat = pat[1:]
	}

	for i := from; i != to; i += incr {
		if begin {
			found = (0 == strings.Compare(s.history[i], pat))
		} else {
			found = strings.Contains(s.history[i], pat)
		}
		if found {
			repeat--
			if 0 == repeat {
				return i
			}
		}
	}
	return -1
}

func insertRunes(line []rune, pos int, ins []rune) []rune {
	if len(line) < pos {
		pos = len(line)
	} else if 0 > pos {
		pos = 0
	}
	add := len(line) + len(ins) - cap(line)
	if 0 < add {
		add += 1024 - (add % 1024)
		origLen := len(line)
		line = line[:cap(line)] // add above existing capacity
		line = append(line, make([]rune, add)...)
		line = line[:origLen]
	}
	line = line[:len(line)+len(ins)]
	if len(line) > pos+len(ins) {
		copy(line[pos+len(ins):], line[pos:])
	}
	copy(line[pos:], ins)
	return line
}
